Of course. Here is the entire architecture document formatted in Markdown (`README.md`). You can copy the text below and paste it directly into Microsoft Word, and it should retain the formatting for headings, lists, bold text, and code blocks.

-----

# Architecture Design Document: TTA and QAA Agentic Integration

## Executive Summary

This document provides a comprehensive architecture design for integrating the Transaction Testing Assistant (TTA) with the QA Agent (QAA) platform, adopting an agentic workflow. As of September 14, 2025, this design establishes a clear separation of duties. In this model, the **TTA application** serves two primary functions: it acts as a **provider of specialized data-preparation tools** for the agentic ecosystem, and it hosts the **Human-in-the-Loop (HITL) interface** for final review and disposition.

The **QAA platform** hosts the **validation supervisor agent**, which orchestrates the core validation logic by consuming the tools exposed by the TTA application. The handoff between the TTA's preparation process and the QAA's validation agent is managed by a resilient, event-driven trigger mechanism. This decoupled architecture ensures modularity, scalability, and fault tolerance, supporting both one-time and batch processing scenarios while aligning with enterprise QA objectives.

-----

## Background and Objectives

### Background

  * **TTA Application Overview**: The TTA is a specialized platform that provides a suite of tools for processing transaction data (e.g., document ingestion, chunking, embedding) and a web application for **Human-in-the-Loop (HITL)** review. Its primary role is to prepare data and manage the user-facing workflow.
  * **QAA Platform Overview**: The QAA is a scalable platform for automating QA workflows. It excels at agentic orchestration, hosting intelligent agents that can consume tools, execute complex logic, and manage validation tasks in a supervised manner.
  * **Integration Rationale**: By integrating these platforms, we leverage their core strengths. The TTA application provides the foundational data processing tools and the user interface, while the QAA platform provides the intelligent agent that drives the automated validation process. This creates a powerful, symbiotic relationship where each platform focuses on its area of expertise.

### Objectives

  * Design an agentic workflow where the TTA application provides tools and the HITL interface, and the QAA agent consumes these tools for validation.
  * Implement a resilient, event-driven invocation mechanism for a seamless, asynchronous handoff.
  * Optimize the processing of large documents through TTA's specialized chunking and ranking tools.
  * Ensure a clear and logical flow where validation results from QAA are routed back to the TTA application for HITL processing.

-----

## Agentic Workflow Approach

The workflow is structured around a clear service-oriented model. The TTA application exposes its capabilities as tools, and the QAA agent acts as the primary consumer.

### 1\. Preparation Phase (within TTA Application)

A TTA preparation agent, operating within the TTA application, is initiated with a Transaction ID (e.g., `TT001`).

1.  **Data Ingestion**: The agent uses internal TTA services to fetch the transaction details, associated documents, and System of Record (SOR) data.
2.  **Preprocessing & Storage**: The agent utilizes TTA's core processing tools to:
      * Extract, clean, and chunk document content into embeddings.
      * Rank chunks for relevance and store the top 5 in a vector database.
3.  **Signal Readiness**: Upon completion, the agent publishes a **`chunks_ready` event** to a message queue. This event contains the Transaction ID and signals that the necessary data artifacts are ready for validation.

### 2\. Invocation and Handoff

The invocation is fully decoupled, ensuring the TTA and QAA systems can operate and scale independently.

  * **Event-Driven Trigger**: The QAA Supervisor Agent, hosted on the QAA platform, is subscribed to the `chunks_ready` topic. It automatically activates upon receiving an event from the message queue.
  * **Resiliency**: This asynchronous pattern provides high resiliency. If the QAA agent is temporarily down, messages will queue until it becomes available, preventing data loss. The invocation framework includes automated retries and health checks.

### 3\. Validation Phase (QAA Agent consuming TTA Tools)

Once activated, the QAA agent orchestrates the validation by calling the tools exposed by the TTA application.
4\.  **Data Retrieval**: The QAA agent makes an API call to the **"Chunk Retrieval Tool"** provided by the TTA application to fetch the top 5 relevant chunks.
5\.  **SOR Data Fetching**: The agent makes another API call to the **"SOR Access Tool"** (also provided by TTA) to get the necessary SOR data for comparison.
6\.  **LLM Validation**: With all the required data, the QAA agent sends a structured prompt to a Large Language Model (LLM) to perform the comparison and identify discrepancies.
7\.  **Return Results**: The QAA agent aggregates the validation results into a structured format (e.g., JSON) and sends them back to a designated endpoint on the TTA application.

### 4\. Completion and HITL (within TTA Application)

The TTA application receives the validation results from the QAA agent and manages the final steps of the workflow.
8\.  **HITL Triage**: The TTA application contains the business logic to analyze the results. If discrepancies are found, the transaction is automatically routed to the **HITL review queue** within the TTA web interface.
9\.  **User Notification & Reporting**: The TTA application notifies the user of the status (e.g., "Completed" or "Review Required") and generates the final audit reports.

-----

## Architecture Design

### High-Level Architecture

The architecture is composed of two primary domains—the TTA Application (Tools & UI) and the QAA Platform (Agent Orchestration)—communicating via a shared messaging infrastructure.

**Key Principles:**

  * **Service-Oriented Tooling**: The TTA application exposes its data capabilities as versioned, stateless APIs (tools) for consumption by any authorized agent, promoting reusability.
  * **Clear Ownership**: TTA owns the data lifecycle and user experience (HITL). QAA owns the automated validation logic and agent orchestration.
  * **Asynchronous Communication**: Event-driven communication is the primary method for inter-service collaboration, maximizing scalability and resilience.
  * **Modularity**: Components are designed to be independently deployable and scalable.

### Layers and Components

1.  **TTA Application Domain**:
      * **User Interface**: The web front-end for initiating tests and performing HITL reviews.
      * **Tooling Layer**: A set of microservices exposing TTA's capabilities via REST APIs (e.g., Chunk Retrieval API, SOR Access API).
      * **Workflow & HITL Logic**: The back-end service that receives results from QAA and manages the HITL queue.
      * **Preparation Agent**: The internal agent that performs the initial data processing.
2.  **QAA Platform Domain**:
      * **Agentic Orchestration Engine**: Hosts and manages the lifecycle of the QAA Supervisor Agent.
      * **QAA Supervisor Agent**: The core intelligent agent that executes the validation plan by calling TTA's tools.
3.  **Shared Infrastructure Layer**:
      * **Message Queue**: (e.g., RabbitMQ, Kafka) for asynchronous event passing.
      * **Databases**: Vector DB for embeddings and a relational DB for metadata, results, and audit trails.
      * **Monitoring & Logging Service**: Centralized logging and performance monitoring for both platforms.

-----

## Detailed Process Flow Diagram

This sequence diagram illustrates the detailed interactions between the components throughout the workflow.

```mermaid
sequenceDiagram
    participant User
    participant TTA_App_UI as TTA Application (UI & HITL)
    participant TTA_Prep_Agent as TTA Preparation Agent
    participant TTA_Tools_API as TTA Tools (API Layer)
    participant Message_Queue as Message Queue
    participant QAA_Agent as QAA Supervisor Agent
    participant LLM

    User->>TTA_App_UI: 1. Initiate Test (Transaction ID)
    TTA_App_UI->>TTA_Prep_Agent: 2. Trigger Preparation Process
    TTA_Prep_Agent->>TTA_Tools_API: 3. Ingest & Process Docs
    TTA_Tools_API-->>TTA_Prep_Agent: 4. Chunks & Embeddings Created
    TTA_Prep_Agent->>Message_Queue: 5. Publish 'chunks_ready' Event

    Message_Queue->>QAA_Agent: 6. Deliver Event (Activate Agent)
    QAA_Agent->>TTA_Tools_API: 7. Call 'GetChunks' Tool
    TTA_Tools_API-->>QAA_Agent: 8. Return Top 5 Chunks
    QAA_Agent->>TTA_Tools_API: 9. Call 'GetSOR' Tool
    TTA_Tools_API-->>QAA_Agent: 10. Return SOR Data
    QAA_Agent->>LLM: 11. Request Validation (Chunks vs SOR)
    LLM-->>QAA_Agent: 12. Return Discrepancies
    QAA_Agent->>TTA_App_UI: 13. Send Final Results

    alt Discrepancies Found
        TTA_App_UI->>TTA_App_UI: 14a. Route to HITL Review Queue
        TTA_App_UI->>User: 15a. Notify: "Review Required"
    else No Discrepancies
        TTA_App_UI->>TTA_App_UI: 14b. Mark as 'Completed'
        TTA_App_UI->>User: 15b. Notify: "Test Completed"
    end
```

Of course. Here is the Mermaid markup for the project flow diagram.

```mermaid
graph TD
    A[User Initiates Test via TTA UI] --> B{TTA Application};

    subgraph "Step 1: Data Preparation (TTA)"
        B --> C[Internal Prep Agent Processes Docs];
        C --> D[Store Chunks & Embeddings];
        D -- in --> VDB[(Vector DB)];
        C --> E[Publish 'chunks_ready' Event];
    end

    subgraph "Step 2: Asynchronous Handoff"
        E -- to --> MQ[(Message Queue)];
        MQ --> F[Trigger QAA Agent];
    end

    subgraph "Step 3: Validation (QAA)"
        F --> G[QAA Agent Calls TTA Tools API];
        G -- gets chunks from --> VDB;
        G -- gets SOR data --> SOR[(SOR Data Source)];
        G --> H[Send Data to LLM for Comparison];
        H --> LLM[(LLM Service)];
        LLM --> I[Return Validation Results];
        I --> J[QAA Agent Aggregates Discrepancies];
    end

    subgraph "Step 4: Completion & HITL (TTA)"
        J --> K{Return Aggregated Results to TTA App};
        K --> L{Check for Discrepancies};
        L -- Yes --> M[Route to HITL Review Queue];
        L -- No --> N[Mark as Completed];
        M --> O[Generate Final Report & Notify User];
        N --> O;
    end
```

graph LR
    %% 1. Create a single invisible node to act as an anchor
    Aligner( )

    %% Style the anchor node to be completely invisible
    style Aligner fill:transparent,stroke:transparent

    subgraph "Step 1: Data Preparation (TTA)"
        direction LR
        A[User Initiates Test] --> C[Prep Agent Processes Docs];
        C --> D[Store Chunks];
        C --> E[Publish Event];
    end

    subgraph "Step 2: Asynchronous Handoff"
        direction LR
        MQ[(Message Queue)] --> F[Trigger QAA Agent];
    end
    
    subgraph "Step 3: Validation (QAA)"
        direction LR
        F --> G[Call TTA Tools];
        G --> H[Send to LLM];
        H --> I[Get Results];
        I --> J[Aggregate];
    end

    subgraph "Step 4: Completion & HITL (TTA)"
        direction LR
        J --> K{Return Results};
        K --> L{Check Discrepancies};
        L --> M[Route to HITL];
        L --> N[Mark Completed];
    end

    %% Connect the actual flow between subgraphs
    E --> MQ

    %% 2. Add invisible links from the anchor to the top of each subgraph
    Aligner ~~~ A
    Aligner ~~~ MQ
    Aligner ~~~ G
    Aligner ~~~ K

    %% 3. Make the alignment links invisible
    %% Note: The numbers (0,1,2,3) correspond to the link order. 
    %% If you add more links before these, you may need to update the indices.
    linkStyle 0 stroke-width:0px
    linkStyle 1 stroke-width:0px
    linkStyle 2 stroke-width:0px
    linkStyle 3 stroke-width:0px
graph LR
    subgraph "TTA App Process"
        A["Step 1: User Uploads Batch <br/> - 10 PDFs (200MB each) <br/> - Assign Batch ID"] --> B["Step 2: TTA App UI: Prompt Configuration <br/> - Select Field Groups <br/> - Add Few-Shot Examples <br/> - Serialize Prompts <br/> - Toggle SOR Verification"]
        
        B --> C1["Step 3a: Dual Storage Check <br/> - Determine Path by Doc Status"]
        
        C1 -->|New/Unmanaged| C2["Step 3b: Save to NAS Drive <br/> - Push to S3 Bucket <br/> - Batch ID Status (Polling/Kafka)"]
        
        C1 -->|Already in Managed| C3["Step 3c: Save/Flag iCMP (FileNet) Blob <br/> - Skip NAS/S3"]
        
        C2 --> D["Step 4: Submit to QAA API <br/> - Include Path Flag <br/> - Send Prompts + Batch ID"]
        
        C3 --> D
        
        J --> K["Step 10: Final Output <br/> - Export JSON/CSV <br/> - Metrics & Notification <br/> - Sample Verified Data"]
    end
    
    subgraph "QAA Process"
        D --> OR["Step 5: Orchestration Agent <br/> - Route by Batch ID/Path <br/> - Chain Agents Sequentially <br/> - Handle Errors <br/> - Monitor Logs/Audits"]
        
        subgraph "Extraction Agent Task (Sequential Start)"
            OR --> E1["Step 6a: Conditional Doc Pull <br/> - NAS/S3: From S3 <br/> - iCMP: From ECM Pipeline"]
            E1 --> E2["Step 6b: Chunking Files <br/> - Split by Pages (500-1000 tokens) <br/> - Parallelize (5 Workers) <br/> - Apply OCR"]
            E2 --> E3["Step 6c: Field Extraction <br/> - Routed Prompt: Few-Shot Groups <br/> - Chain: {prev_results} <br/> - LLM: Extract JSON <br/> - 200 Fields"]
            E3 --> OR["Output: Chunk JSONs <br/> - Pass to Aggregation"]
        end
        
        subgraph "Aggregation Agent Task (After Extraction)"
            OR --> F1["Step 7a: Merge Outputs <br/> - Collect JSONs <br/> - Pandas/Spark Merge <br/> - Dedupe Borrower ID"]
            F1 --> F2["Step 7b: Aggregation Logic <br/> - Routed Prompt: Chain {extract_outputs} <br/> - Flag Low-Confidence <br/> - Cross-Reference Docs"]
            F2 --> F3["Step 7c: Scalability Check <br/> - Distributed Nodes <br/> - Monitor Logs <br/> - Handle ~2GB"]
            F3 --> OR["Output: Unified Dataset <br/> - Pass to Reasoning"]
        end
        
        subgraph "Reasoning Agent Task (After Aggregation)"
            OR --> G1["Step 8a: Fetch SOR Fields <br/> - API Call: /get-sor-fields <br/> - Batch ID + Txn IDs <br/> - Pull CORE/DB <br/> - Fallback: S3 Cache"]
            G1 --> G2["Step 8b: Verify Transactions <br/> - Routed Prompt: Chain {data} + SOR <br/> - Compare Extracted vs. SOR <br/> - Flag Mismatches/Reasons <br/> - Infer Missing"]
            G2 --> G3["Step 8c: Holistic Reasoning <br/> - Business Rules Check <br/> - Dispute Flags (~1.6%) <br/> - Prepare HITL Summary"]
            G3 --> OR["Output: Verified JSON <br/> - Pass to HITL"]
        end
        
        OR --> H["Step 9a: HITL Review in QAA App <br/> - View Flags/Disputes <br/> - Human Validates/Resolves <br/> - Escalate to Supervisory <br/> - Kept in QAA"]
        
        H --> I["Step 9b: Target System: SOR Final Validation <br/> - Cross-Check Review <br/> - Store in DB (Mongo) <br/> - Generate Report <br/> - SOR Only (No HITL)"]
        
        I --> J["Step 9c: Supervisory Review <br/> - Senior Check Disputes <br/> - Approve Dataset <br/> - Update Audit Trail"]
    end
    
    subgraph "Prompt Management Overlay"
        B -.->|"Pass All 3 Prompts w/ Batch ID (JSON)"| D
        D -.->|"QAA Routes to Agents (Cache Fetch)"| OR
    end
    
    G1 --> SOR["SOR API <br/> - Endpoint: /get-sor-fields <br/> - Filters: Batch ID + Txn IDs <br/> - Response: JSON Data <br/> - Auth: API Keys/OAuth"]
    
    style A fill:#d9f7be,stroke:#68d391
    style B fill:#d9f7be,stroke:#68d391
    style C1 fill:#d9f7be,stroke:#68d391
    style C2 fill:#d9f7be,stroke:#68d391
    style C3 fill:#d9f7be,stroke:#68d391
    style D fill:#d9f7be,stroke:#68d391
    style K fill:#d9f7be,stroke:#68d391
    style OR fill:#bee3f8,stroke:#4299e1
    style E1 fill:#bee3f8,stroke:#4299e1
    style E2 fill:#bee3f8,stroke:#4299e1
    style E3 fill:#bee3f8,stroke:#4299e1
    style F1 fill:#bee3f8,stroke:#4299e1
    style F2 fill:#bee3f8,stroke:#4299e1
    style F3 fill:#bee3f8,stroke:#4299e1
    style G1 fill:#bee3f8,stroke:#4299e1
    style G2 fill:#bee3f8,stroke:#4299e1
    style G3 fill:#bee3f8,stroke:#4299e1
    style H fill:#bee3f8,stroke:#4299e1
    style I fill:#bee3f8,stroke:#4299e1
    style J fill:#bee3f8,stroke:#4299e1
    style SOR fill:#fed7aa,stroke:#f97316


