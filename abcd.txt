# tracing.py
"""
HTTP-only tracing for Google ADK (gRPC blocked, SSL verify=False enforced).
ADK is optional—skips if not installed.
"""

import os
import sys

# FORCE HTTP BEFORE ANY IMPORTS (stops gRPC default)
os.environ['OTEL_EXPORTER_OTLP_PROTOCOL'] = 'http/protobuf'

# Block gRPC import (exits if present)
try:
    import opentelemetry.exporter.otlp.proto.grpc
    print("ERROR: gRPC detected. Run 'pip uninstall opentelemetry-exporter-otlp-proto-grpc -y' and restart.")
    sys.exit(1)
except ImportError:
    pass

import logging
import certifi
import requests
from typing import Optional, Dict

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Set CA bundle (ignored for verify=False)
os.environ['REQUESTS_CA_BUNDLE'] = certifi.where()

# OTel imports with safeguards
try:
    from opentelemetry import trace
    from opentelemetry.sdk.resources import Resource
    from opentelemetry.sdk.trace import TracerProvider
    from opentelemetry.sdk.trace.export import BatchSpanProcessor
    from opentelemetry.exporter.otlp.proto.http.trace_exporter import OTLPSpanExporter as BaseHttpExporter
    OTel_AVAILABLE = True
except ImportError as e:
    logger.error(f"OTel import failed: {e}. Install 'opentelemetry-sdk opentelemetry-exporter-otlp[http]'")
    OTel_AVAILABLE = False
    raise

# ADK (optional—skips if not installed)
ADK_AVAILABLE = False
try:
    from openinference.instrumentation.google_adk import GoogleADKInstrumentor
    ADK_AVAILABLE = True
except ImportError:
    logger.warning("ADK instrumentation missing. Install 'openinference-instrumentation-google_adk google-adk' for full ADK tracing.")

# Phoenix (optional)
PHOENIX_AVAILABLE = False
phoenix_register = None
try:
    from phoenix.otel import register as phoenix_register
    PHOENIX_AVAILABLE = True
except ImportError:
    logger.debug("Phoenix skipped. Install 'arize-phoenix-otel' for metadata")

# CustomHttpExporter (verify=False enforced for insecure)
class CustomHttpExporter(BaseHttpExporter):
    def __init__(self, endpoint: str, insecure: bool = False, timeout: int = 30000, **kwargs):
        super().__init__(endpoint=endpoint, **kwargs)
        self._session = requests.Session()
        self._session.verify = not insecure  # False if insecure=True
        self._session.trust_env = False
        adapter = requests.adapters.HTTPAdapter(pool_connections=10, pool_maxsize=10, max_retries=3)
        self._session.mount('https://', adapter)
        if insecure:
            import urllib3
            urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
        logger.info(f"CustomHttpExporter: endpoint={endpoint}, verify={not insecure} (insecure mode active)")

_tracing_initialized = False

def init_tracing(
    endpoint: str,  # Required OCP URL
    insecure: bool = True,  # Default True for OCP self-signed
    service_name: str = "adk-agent",
    timeout: int = 30000,
    project_name: str = "adk-default-project",
    ax_mode: bool = False,
    test_connectivity: bool = False
) -> None:
    global _tracing_initialized
    if _tracing_initialized:
        return

    # Validate endpoint
    if "localhost" in endpoint.lower() or "4317" in endpoint:
        raise ValueError(f"Invalid endpoint '{endpoint}' - Use OCP HTTPS /v1/traces")
    if not endpoint.endswith('/v1/traces'):
        endpoint += '/v1/traces'
    logger.info(f"Init: endpoint={endpoint}, insecure={insecure}, ax_mode={ax_mode}")

    # Resource
    attributes = {'service.name': service_name}
    if ax_mode:
        attributes['arize.project.name'] = project_name
    else:
        attributes['phoenix.project.name'] = project_name
    resource = Resource(attributes=attributes)
    provider = TracerProvider(resource=resource)
    trace.set_tracer_provider(provider)

    # Connectivity test (optional)
    if test_connectivity:
        test_session = requests.Session()
        test_session.verify = not insecure
        try:
            resp = test_session.head(endpoint, timeout=timeout / 1000)
            logger.info(f"Connectivity: {resp.status_code}")
        except Exception as e:
            logger.warning(f"Connectivity failed: {e}")

    # Exporter (insecure enforced)
    try:
        exporter = CustomHttpExporter(endpoint=endpoint, insecure=insecure, timeout=timeout)
        span_processor = BatchSpanProcessor(exporter, max_export_batch_size=512)
        provider.add_span_processor(span_processor)
        logger.info("Exporter initialized (HTTP-only, verify=False)")
    except Exception as e:
        logger.error(f"Exporter failed: {e}")
        raise

    # Phoenix registration (always pass endpoint for OCP/custom)
    if PHOENIX_AVAILABLE:
        try:
            phoenix_register(
                project_name=project_name,
                endpoint=endpoint,  # Always pass full OTLP URL
                auto_instrument=True
            )
            logger.info("Phoenix registered with custom endpoint")
        except Exception as e:
            logger.warning(f"Phoenix registration skipped: {e}")

    # ADK (optional)
    if ADK_AVAILABLE:
        try:
            GoogleADKInstrumentor().instrument(tracer_provider=provider)
            logger.info("ADK instrumented")
        except Exception as e:
            logger.warning(f"ADK skipped: {e}")

    # Test export (dummy span to flush immediately)
    try:
        test_tracer = trace.get_tracer(__name__)
        with test_tracer.start_as_current_span("init-test"):
            pass
        provider.force_flush(timeout_millis=5000)
        logger.info("Test export successful - no gRPC/SSL errors")
    except Exception as e:
        logger.warning(f"Test export failed: {e} - Check OCP endpoint")

    _tracing_initialized = True

# Tool span helper
def create_tool_span(tool_name: str, input_data: Dict, parent_span=None) -> Optional[trace.Span]:
    if not OTel_AVAILABLE:
        return None
    tracer = trace.get_tracer(__name__)
    span = tracer.start_span(
        name=f"tool.{tool_name}",
        attributes={"tool.name": tool_name, "tool.input": str(input_data), "span.kind": "TOOL"}
    )
    if parent_span:
        span.set_parent(parent_span.get_span_context())
    return span
