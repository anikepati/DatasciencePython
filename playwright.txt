# agent.py
import os
from google.adk.agents import LlmAgent
from google.adk.tools.mcp_tool.mcp_toolset import MCPToolset
from google.adk.tools.mcp_tool.mcp_session_manager import StdioConnectionParams
from mcp import StdioServerParameters
from pydantic import BaseModel, Field

# Define a tool to get credentials
class GetCredentialsInput(BaseModel):
    pass  # No input needed

def get_credentials(input: GetCredentialsInput) -> dict:
    """
    Retrieves the username and password for Microsoft admin login.
    Returns a dictionary with 'username' and 'password'.
    """
    username = os.environ.get("MS_USERNAME", "default_username")  # Set via environment variable
    password = os.environ.get("MS_PASSWORD", "default_password")  # Set via environment variable
    return {"username": username, "password": password}

# URLs as constants (replace with actual if needed)
POWER_PLATFORM_URL = "https://admin.powerplatform.microsoft.com/"
M365_ADMIN_URL = "https://admin.microsoft.com/"
# Assume Dynamics app URL if needed, but using PPAC for most

root_agent = LlmAgent(
    model="gemini-2.0-flash",  # Use the latest Gemini model available in ADK
    name="dynamics_automator",
    description="An AI agent that automates the creation of business units, teams, shared mailbox, and queue in Microsoft Dynamics 365 and Microsoft 365 using browser automation tools.",
    instruction="""
You are an enterprise-grade automation agent for setting up Microsoft Dynamics 365 smart mailbox with business units and teams. Your goal is to automate the following task reliably, ensuring execution at any cost by incorporating resilience strategies. Use up to 10 retries for any failed action (e.g., if an element is not found or click fails, inspect the page again with browser_snapshot, scroll, wait, and retry). Always prioritize resilient practices: use stable selectors like text-based or role-based from snapshots, auto-wait with browser_wait_for before interactions, verify page state after actions. To handle MFA and prevent premature browser closing, during login steps, use extended waits (browser_wait_for with timeout=60s or more) for MFA prompts to allow manual intervention since the browser is headed. Monitor for login completion by checking for dashboard elements post-MFA.

Task steps:
1. Open the Power Platform admin center by navigating to {power_platform_url}. After navigation, use browser_wait_for to ensure the page is loaded (e.g., wait for body or a key element with timeout=30s), then snapshot to confirm.
2. If a sign-in prompt appears (check snapshot for login fields), use the get_credentials tool to obtain the username and password, fill them in the appropriate fields (use browser_type), and click 'Sign In' or 'Next'. If MFA prompt appears (e.g., wait for elements like 'Verify your identity'), use browser_wait_for with extended timeout (60-120s) to allow manual approval (e.g., push notification on phone). After MFA, wait for redirect to dashboard (browser_wait_for dashboard selector like navigation pane). Retry if fails, up to 10 times with increasing waits.
3. In the navigation pane, select Environments. If not visible, scroll (browser_press_key 'PageDown', count=5), resnapshot, retry up to 10 times. Use browser_wait_for visibility.
4. Select the target environment named "ABC OPS POC" (prefer text selector). If not visible, scroll down using browser_press_key ('PageDown', count=5), resnapshot, retry up to 10 times.
5. In the command bar, select Settings. Verify post-click with another snapshot and browser_wait_for settings load.
6. Expand Users + permissions, then select Business units. If expansion not visible, scroll, wait for loading (browser_wait_for selector if spinner exists, timeout=20s), resnapshot, retry up to 10 times.
7. On the Business Units page, select New business unit in the command bar. Wait for panel (browser_wait_for).
8. In the Create new business unit panel, fill in the name field with "Parent BU" (browser_type). The Parent business unit is pre-filled with root; leave it. Complete optional fields if prompted, then click Save. Handle any dialogs with browser_handle_dialog.
9. Wait for the business unit to be created (browser_wait_for list update, timeout=30s), resnapshot to confirm it appears in the list. If not, refresh page (browser_press_key 'F5') and retry.
10. Select New business unit again to create the child.
11. Fill in the name with "Child BU", use the dropdown for Parent business unit to select "Parent BU" (use browser_select_option or click and type to search, then select). Click Save.
12. Confirm the child appears under the parent in the hierarchy via snapshot. If not visible, scroll or refresh.
13. In the same Settings, select Teams under Users + permissions. If not directly available, search or navigate accordingly; retry with scroll and wait up to 10 times.
14. Select New team.
15. Enter team name "New Team", select business unit "Child BU" via lookup (click lookup, type "Child BU", select), enter administrator (type current username or a known user, e.g., search and select first), select Team Type "Owner", complete other fields, click Save.
16. Confirm team created via snapshot.
17. Navigate to Microsoft 365 admin center at {m365_admin_url}. Wait for load (browser_wait_for), sign in if prompted (repeat login step with MFA handling).
18. In the left navigation, expand Teams & groups > Shared mailboxes (select Show all if needed). Scroll or wait if not visible, retry up to 10 times.
19. Select + Add a shared mailbox.
20. Enter name "Smart Mailbox", which sets the email address, edit if needed, select Save changes. Wait a few seconds (browser_wait_for confirmation).
21. Under Next steps, select Add members to this mailbox. Add members: search and add a user (e.g., the admin username), then Add and close.
22. To block sign-in: Go to Users > Active users. Find the shared mailbox account (search by name or filter unlicensed), select it, then Block sign-in > Block the user from signing in > Save changes.
23. Navigate back to Power Platform admin center {power_platform_url}, or refresh if possible. Handle login again if session expired.
24. Select the environment "ABC OPS POC" > Settings > Business > select Queues (if not, navigate to Customer Service admin or hub if needed).
25. Select New to create a new queue.
26. Provide Name "Smart Queue", Type: Public, Incoming Email: the shared mailbox email (e.g., type "smartmailbox@domain.com" - assume from env or hardcoded), Convert Incoming Email To Activities: All email messages, Owner: select the "New Team" via lookup (search "New Team", select), Description optional, click Save. This auto-creates a mailbox.
27. Once saved, click on the Mailbox link in the queue record.
28. In the mailbox record, select Approve Email > OK.
29. Then select Test & Enable Mailbox > OK.
30. Wait and refresh (browser_press_key 'F5' or navigate), check status with snapshot; Incoming and Outgoing should show Success. Retry refresh up to 5 times if not.
31. Output "Task completed successfully." and close the browser only after full confirmation.

Enhanced Resilience strategies:
- Increase all waits and retries to handle flakiness: browser_wait_for with timeouts up to 60s for critical steps like login/MFA.
- Before every interaction, take a browser_snapshot to get the latest refs and confirm element presence/visibility/enabled state.
- For deterministic behavior, always verify post-action state with snapshot and conditional waits; if unexpected, retry the step.
- If element not found or interaction fails, retry sequence: wait 5-10s, scroll (press_key 'PageDown' 5-10 times), resnapshot, attempt again up to 10 times.
- Handle session expirations by re-logging in if sign-in prompt reappears.
- Describe elements human-readably in 'element' but use exact 'ref' from snapshot for actions.
- Handle unexpected states: if dialog appears, use browser_handle_dialog (accept if confirmation).
- After major actions (navigate, click leading to load), verify with snapshot that expected content is present; if not, backtrack (e.g., re-navigate) or retry.
- If network issues or timeouts, retry the action up to 10 times with exponential backoff (increase wait by 2x each time).
- For lookups/dropdowns, if select_option fails, use type to search, press 'Enter', or click first result.
- Run cautiously to avoid infinite loops; after max retries per step, log failure but proceed to next if possible, or abort with error message.

Start the task immediately upon receiving the user prompt "Start automation".
""".format(power_platform_url=POWER_PLATFORM_URL, m365_admin_url=M365_ADMIN_URL),
    tools=[
        get_credentials,  # Add the credentials tool
        MCPToolset(
            connection_params=StdioConnectionParams(
                server_params=StdioServerParameters(
                    command="npx",
                    args=[
                        "-y",
                        "@playwright/mcp@latest",
                        "--headless=false",  # Run headed for visual debugging and manual MFA
                        "--slow-mo=1000",  # Increase slow-mo to 1000ms for more deterministic timing
                    ],
                ),
            ),
            tool_filter=[
                "browser_navigate",
                "browser_click",
                "browser_type",
                "browser_snapshot",
                "browser_wait_for",
                "browser_select_option",
                "browser_press_key",
                "browser_handle_dialog",
                "browser_close",
            ],
        ),
    ],
)

# run_automation.py (for running the agent asynchronously, modular runner)
import asyncio
import os
from dotenv import load_dotenv
from google.genai import types
from google.adk.agents.llm_agent import LlmAgent
from google.adk.runners import Runner
from google.adk.sessions import InMemorySessionService
from google.adk.artifacts.in_memory_artifact_service import InMemoryArtifactService
from multi_tool_agent.agent import root_agent, MCPToolset  # Adjust import based on your folder structure

load_dotenv()  # Load environment variables for credentials

async def async_main():
    session_service = InMemorySessionService()
    artifacts_service = InMemoryArtifactService()
    session = await session_service.create_session(state={}, app_name='dynamics_automator', user_id='automation_user')
    
    # Prompt to start the automation
    query = "Start automation"
    content = types.Content(role='user', parts=[types.Part(text=query)])
    
    # Assuming root_agent is defined synchronously; for async tools like MCP, manage cleanup
    toolset = root_agent.tools[1]  # The MCPToolset instance
    runner = Runner(app_name='dynamics_automator', agent=root_agent, artifact_service=artifacts_service, session_service=session_service)
    
    async for event in runner.run_async(session_id=session.id, user_id=session.user_id, new_message=content):
        print(f"Event received: {event}")
    
    # Cleanup
    await toolset.close()

if __name__ == '__main__':
    asyncio.run(async_main())

system ğŸ§ ğŸ’¼
Youâ€™ll simply run python main.py, and the agent will read a natural language enterprise task description (like a paragraph of instructions), interpret it, reason about what to do, decrypt credentials, and perform the full workflow automatically inside Chrome.

ğŸ¯ Your Use Case

You want to describe everything in natural language once â€” e.g.:

Go to https://portal.company.com/login, log in using my user ID sunil@company.com and the encrypted password below, decrypt it, enter it, click Login. 
After login, click on the 'New Email Registration' link, fill in the form with name Sunil Anikepati, email sunil@company.com, department Engineering, and submit the form.


The system will:

Parse & understand this natural text (via LLM reasoning),

Decrypt the password (using cryptography.Fernet),

Execute all browser actions with Playwright,

Behave like a human â€” dynamic DOM understanding, no fixed selectors,

Take before/after snapshots,

Run entirely autonomously (no user input).

ğŸ§© Project Structure
enterprise_agentic_browser/
â”‚
â”œâ”€â”€ main.py
â”œâ”€â”€ agents/
â”‚   â””â”€â”€ enterprise_agent.py
â”œâ”€â”€ tools/
â”‚   â””â”€â”€ agentic_playwright_tool.py
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ task_description.txt      # Your full natural language task
â”‚   â””â”€â”€ encryption_key.txt        # Encryption key for password decryption
â”œâ”€â”€ secrets/
â”‚   â””â”€â”€ encrypted_password.txt    # Encrypted password file
â”œâ”€â”€ requirements.txt
â””â”€â”€ README.md

âš™ï¸ requirements.txt
google-adk
playwright
fastmcp
google-generativeai
cryptography


Install setup:

pip install -r requirements.txt
playwright install chrome

ğŸ” Step 1: Password Encryption Utility (run once)
# encrypt_password.py
from cryptography.fernet import Fernet

# Generate key once
key = Fernet.generate_key()
with open("config/encryption_key.txt", "wb") as f:
    f.write(key)

fernet = Fernet(key)

password = input("Enter password to encrypt: ").strip()
encrypted = fernet.encrypt(password.encode())

with open("secrets/encrypted_password.txt", "wb") as f:
    f.write(encrypted)

print("âœ… Password encrypted and stored securely.")

ğŸ¤– Step 2: Agentic Playwright Tool (tools/agentic_playwright_tool.py)

This is the heart of the system â€” it reads the task, decrypts credentials, reasons about the page, and acts.

from fastmcp import tool
from playwright.sync_api import sync_playwright
import google.generativeai as genai
from cryptography.fernet import Fernet
import os, time, json

SNAPSHOT_DIR = "snapshots"
os.makedirs(SNAPSHOT_DIR, exist_ok=True)

# Configure Gemini reasoning model
genai.configure(api_key=os.environ.get("GOOGLE_API_KEY"))
model = genai.GenerativeModel("gemini-1.5-pro")

def decrypt_password():
    """Decrypt enterprise password from files."""
    key = open("config/encryption_key.txt", "rb").read()
    encrypted = open("secrets/encrypted_password.txt", "rb").read()
    fernet = Fernet(key)
    return fernet.decrypt(encrypted).decode()

@tool("enterprise_browser_tool")
def execute_enterprise_task(task_text: str):
    """
    Fully agentic browser automation based on natural-language task description.
    Steps:
    1. Reads human instructions.
    2. Uses LLM to reason which actions to take (enter text, click, etc.).
    3. Executes all browser operations dynamically with Playwright.
    """
    with sync_playwright() as p:
        browser = p.chromium.launch(headless=False, args=["--start-maximized"])
        page = browser.new_page()

        print("\nğŸ¤– Reading enterprise task...")
        print(task_text)

        # Inject decrypted password
        password = decrypt_password()
        task_text = task_text.replace("{{password}}", password)

        # Step 1: Ask LLM for structured reasoning plan
        planning_prompt = f"""
        You are an enterprise automation agent controlling a Chrome browser.
        Based on the user's instruction below, generate a structured step-by-step plan.
        Each step should include an action type ("go_to", "type", "click", "wait", "screenshot"),
        and a target (preferably by human-readable description, not fixed selectors).

        Instructions:
        {task_text}

        Respond in JSON list format, for example:
        [
            {{"action": "go_to", "target": "https://portal.company.com/login"}},
            {{"action": "type", "target": "user id field", "value": "sunil@company.com"}},
            {{"action": "type", "target": "password field", "value": "myPassword"}},
            {{"action": "click", "target": "Login button"}},
            {{"action": "click", "target": "New Email Registration link"}},
            {{"action": "type", "target": "name field", "value": "Sunil Anikepati"}},
            {{"action": "type", "target": "email field", "value": "sunil@company.com"}},
            {{"action": "type", "target": "department field", "value": "Engineering"}},
            {{"action": "click", "target": "Submit button"}}
        ]
        """
        print("ğŸ§  LLM generating browser plan...")
        reasoning = model.generate_content(planning_prompt)
        plan_text = reasoning.text
        print("ğŸ“œ Plan:", plan_text)

        try:
            plan = json.loads(plan_text)
        except:
            print("âš ï¸ Could not parse plan. Exiting.")
            browser.close()
            return

        # Step 2: Execute plan dynamically
        for step in plan:
            action = step.get("action")
            target = step.get("target", "")
            value = step.get("value", "")

            if action == "go_to":
                page.goto(target, wait_until="domcontentloaded")
                page.screenshot(path=f"{SNAPSHOT_DIR}/step_goto.png")

            elif action == "type":
                # Ask LLM to find the element dynamically from DOM
                dom = page.content()
                reasoning_prompt = f"""
                You are an automation reasoning model.
                Find the best Playwright locator for this description: "{target}".
                Here is partial DOM:
                {dom[:8000]}
                Return JSON: {{"locator_strategy": "text|css|xpath", "locator_value": "..."}}.
                """
                locator_reasoning = model.generate_content(reasoning_prompt)
                try:
                    loc_json = json.loads(locator_reasoning.text)
                except:
                    loc_json = {"locator_strategy": "text", "locator_value": target}

                locator = page.get_by_text(loc_json["locator_value"]) if loc_json["locator_strategy"] == "text" else page.locator(loc_json["locator_value"])
                if locator.count() > 0:
                    locator.first.fill(value)
                    print(f"âŒ¨ï¸ Typed '{value}' into {target}")
                else:
                    print(f"âš ï¸ Could not locate {target}")

            elif action == "click":
                dom = page.content()
                click_prompt = f"""
                You are an automation model.
                Find the clickable element in the DOM corresponding to: "{target}".
                Here is partial DOM:
                {dom[:8000]}
                Return JSON: {{"locator_strategy": "text|css|xpath", "locator_value": "..."}}.
                """
                click_reasoning = model.generate_content(click_prompt)
                try:
                    click_json = json.loads(click_reasoning.text)
                except:
                    click_json = {"locator_strategy": "text", "locator_value": target}

                locator = page.get_by_text(click_json["locator_value"]) if click_json["locator_strategy"] == "text" else page.locator(click_json["locator_value"])
                if locator.count() > 0:
                    locator.first.click()
                    print(f"ğŸ–±ï¸ Clicked on {target}")
                    time.sleep(2)
                    page.screenshot(path=f"{SNAPSHOT_DIR}/after_click_{target.replace(' ', '_')}.png")
                else:
                    print(f"âš ï¸ Could not find element to click: {target}")

            elif action == "wait":
                delay = int(step.get("value", 2))
                print(f"â³ Waiting {delay}s...")
                time.sleep(delay)

            elif action == "screenshot":
                path = f"{SNAPSHOT_DIR}/manual_snapshot_{int(time.time())}.png"
                page.screenshot(path=path)
                print(f"ğŸ“¸ Saved snapshot: {path}")

        browser.close()
        print("âœ… Enterprise automation completed successfully.")

ğŸ§  Step 3: Define Agent (agents/enterprise_agent.py)
from google.adk import Agent
from tools.agentic_playwright_tool import execute_enterprise_task

EnterpriseAgent = Agent(
    name="EnterpriseAutomationAgent",
    description="Understands and executes complex enterprise automation workflows in the browser using reasoning and Playwright.",
    tools=[execute_enterprise_task],
)

ğŸš€ Step 4: Runner (main.py)
import asyncio
from google.adk import Runner
from agents.enterprise_agent import EnterpriseAgent

async def main():
    print("=== ğŸ§  Enterprise Agentic Automation ===")
    with open("config/task_description.txt") as f:
        task_text = f.read().strip()

    runner = Runner(agents=[EnterpriseAgent])
    await runner.run(task_text)
    await runner.destroy(EnterpriseAgent)

if __name__ == "__main__":
    asyncio.run(main())

ğŸ“ Step 5: Task Description (config/task_description.txt)
Go to https://portal.company.com/login, log in using my user ID sunil@company.com and the encrypted password {{password}}, 
decrypt it, enter it, and click the Login button.
After login, click on the "New Email Registration" link and fill the form:
Name: Sunil Anikepati
Email: sunil@company.com
Department: Engineering
Then click Submit and take a screenshot after submission.

âœ… How to Run
export GOOGLE_API_KEY="your-gemini-api-key"
python main.py

ğŸ§© How It Works
Stage	Description
Task Parsing	Reads your natural language file and decrypts password placeholders.
LLM Planning	Gemini creates structured JSON step plan (navigate, type, click).
Dynamic Reasoning	For each step, the agent re-analyzes DOM to find elements â€” no selectors needed.
Execution	Playwright executes each action and takes screenshots.
Autonomy	No user input. Full flow from login â†’ form fill â†’ submit.
ğŸ”’ Enterprise-Grade Features
Feature	Description
ğŸ§  LLM Reasoning	Understands intent dynamically from instructions
ğŸ§© No Hardcoded Selectors	Learns DOM live each time
ğŸ” Encrypted Credentials	Secure password storage and decryption
ğŸ–¼ï¸ Snapshots	Before/after visual logs
ğŸ§¹ Clean Lifecycle	Agent created/destroyed automatically
ğŸ“¦ Extendable
