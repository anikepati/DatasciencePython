# agent.py
import os
from google.adk.agents import LlmAgent
from google.adk.tools.mcp_tool.mcp_toolset import MCPToolset
from google.adk.tools.mcp_tool.mcp_session_manager import StdioConnectionParams
from mcp import StdioServerParameters
from pydantic import BaseModel, Field

# Define a tool to get credentials
class GetCredentialsInput(BaseModel):
    pass  # No input needed

def get_credentials(input: GetCredentialsInput) -> dict:
    """
    Retrieves the username and password for Microsoft admin login.
    Returns a dictionary with 'username' and 'password'.
    """
    username = os.environ.get("MS_USERNAME", "kavitha.kolahalam@wellsfargo.com")  # Default to provided email
    password = os.environ.get("MS_PASSWORD", "default_password")  # Set via environment variable
    return {"username": username, "password": password}

# URLs as constants
POWER_PLATFORM_URL = "https://admin.powerplatform.microsoft.com/"
M365_ADMIN_URL = "https://admin.microsoft.com/"

root_agent = LlmAgent(
    model="gemini-2.0-flash",  # Use the latest Gemini model available in ADK
    name="dynamics_automator",
    description="An AI agent that automates the creation of business units, teams, shared mailbox, and queue in Microsoft Dynamics 365 and Microsoft 365 using browser automation tools.",
    instruction="""
You are an enterprise-grade automation agent for setting up Microsoft Dynamics 365 smart mailbox with business units and teams. Your goal is to automate the task using natural language processing of the steps, reliably, ensuring execution at any cost by incorporating resilience strategies. Use up to 10 retries for any failed action. Always use stable selectors like role='textbox' with name, role='button' with name, etc., from snapshots.

Task steps in natural language:
1. Navigate to the Power Platform admin center at https://admin.powerplatform.microsoft.com. Wait for the page to load.
2. If sign-in prompt appears, fill the email textbox with the username from get_credentials, click 'Next'.
3. For MFA, wait extended time (browser_wait_for with timeout=120000) to allow manual entry/approval, then wait for URL containing '/home' or dashboard load.
4. Click the tab or link for 'Manage users, environments'.
5. Click the link for the environment 'WIM OPS POC'.
6. Wait for URL matching the manage environment pattern.
7. Click the link 'See all Business units'.
8. Click the menuitem or button 'New business unit'.
9. Click and fill the textbox 'Name *' with 'COO O2A PARENT DEMO555'.
10. Click 'Save'.
11. Wait 2 seconds (browser_wait_for timeout=2000).
12. Click 'New business unit' again.
13. Click and fill 'Name *' with 'COO O2A CHILD DEMO555'.
14. Click the combobox for 'Parent business unit dropdown', fill with 'COO', then click the option 'COO O2A PARENT DEMO'.
15. Click 'Save'.
16. Wait 2 seconds.
17. Click the tab 'Manage users, environments'.
18. Click 'WIM OPS POC'.
19. Click 'See all Teams'.
20. Click 'Create team'.
21. Click and fill 'Team name *' with 'COO O2A TEAMS DEMO555'.
22. Click and fill 'Description' with 'Test demo descript'.
23. Complete team creation by filling/selecting any remaining required fields (e.g., business unit 'COO O2A CHILD DEMO555' via lookup, administrator via search), then click 'Save' or 'Create'.
24. Confirm team created.
25. Proceed to shared mailbox creation: Navigate to Microsoft 365 admin center at https://admin.microsoft.com. Handle login/MFA similarly.
26. Expand 'Teams & groups' > 'Shared mailboxes' (show all if needed).
27. Click '+ Add a shared mailbox'.
28. Enter name 'Smart Mailbox', save changes. Wait.
29. Add members (e.g., add the admin user).
30. Block sign-in for the mailbox user in 'Users > Active users'.
31. Back to Power Platform, navigate to environment 'WIM OPS POC' > Settings > Business > Queues.
32. Click 'New' queue.
33. Fill Name 'Smart Queue', Type 'Public', Incoming Email with the shared mailbox email, Convert to 'All email messages', Owner select 'COO O2A TEAMS DEMO555', save.
34. Click Mailbox link, approve email, test & enable mailbox.
35. Wait/refresh to confirm success.
36. Output "Task completed successfully." and close browser.

Enhanced Resilience:
- Use browser_snapshot before each interaction to find exact refs, use role and name selectors as in the code (e.g., getByRole('textbox', {name: 'Name *'})).
- For MFA and loads, use long timeouts.
- Retry with scroll, wait, refresh if element not found.
- Handle dialogs, verify post-action states.

Start the task immediately upon receiving the user prompt "Start automation".
""",
    tools=[
        get_credentials,
        MCPToolset(
            connection_params=StdioConnectionParams(
                server_params=StdioServerParameters(
                    command="npx",
                    args=[
                        "-y",
                        "@playwright/mcp@latest",
                        "--headless=false",
                        "--slow-mo=1000",
                    ],
                ),
            ),
            tool_filter=[
                "browser_navigate",
                "browser_click",
                "browser_type",
                "browser_snapshot",
                "browser_wait_for",
                "browser_select_option",
                "browser_press_key",
                "browser_handle_dialog",
                "browser_close",
            ],
        ),
    ],
)

# run_automation.py (for running the agent asynchronously, modular runner)
import asyncio
import os
from dotenv import load_dotenv
from google.genai import types
from google.adk.agents.llm_agent import LlmAgent
from google.adk.runners import Runner
from google.adk.sessions import InMemorySessionService
from google.adk.artifacts.in_memory_artifact_service import InMemoryArtifactService
from multi_tool_agent.agent import root_agent, MCPToolset  # Adjust import based on your folder structure

load_dotenv()  # Load environment variables for credentials

async def async_main():
    session_service = InMemorySessionService()
    artifacts_service = InMemoryArtifactService()
    session = await session_service.create_session(state={}, app_name='dynamics_automator', user_id='automation_user')
    
    # Prompt to start the automation
    query = "Start automation"
    content = types.Content(role='user', parts=[types.Part(text=query)])
    
    # Assuming root_agent is defined synchronously; for async tools like MCP, manage cleanup
    toolset = root_agent.tools[1]  # The MCPToolset instance
    runner = Runner(app_name='dynamics_automator', agent=root_agent, artifact_service=artifacts_service, session_service=session_service)
    
    async for event in runner.run_async(session_id=session.id, user_id=session.user_id, new_message=content):
        print(f"Event received: {event}")
    
    # Cleanup
    await toolset.close()

if __name__ == '__main__':
    asyncio.run(async_main())

system ğŸ§ ğŸ’¼
Youâ€™ll simply run python main.py, and the agent will read a natural language enterprise task description (like a paragraph of instructions), interpret it, reason about what to do, decrypt credentials, and perform the full workflow automatically inside Chrome.

ğŸ¯ Your Use Case

You want to describe everything in natural language once â€” e.g.:

Go to https://portal.company.com/login, log in using my user ID sunil@company.com and the encrypted password below, decrypt it, enter it, click Login. 
After login, click on the 'New Email Registration' link, fill in the form with name Sunil Anikepati, email sunil@company.com, department Engineering, and submit the form.


The system will:

Parse & understand this natural text (via LLM reasoning),

Decrypt the password (using cryptography.Fernet),

Execute all browser actions with Playwright,

Behave like a human â€” dynamic DOM understanding, no fixed selectors,

Take before/after snapshots,

Run entirely autonomously (no user input).

ğŸ§© Project Structure
enterprise_agentic_browser/
â”‚
â”œâ”€â”€ main.py
â”œâ”€â”€ agents/
â”‚   â””â”€â”€ enterprise_agent.py
â”œâ”€â”€ tools/
â”‚   â””â”€â”€ agentic_playwright_tool.py
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ task_description.txt      # Your full natural language task
â”‚   â””â”€â”€ encryption_key.txt        # Encryption key for password decryption
â”œâ”€â”€ secrets/
â”‚   â””â”€â”€ encrypted_password.txt    # Encrypted password file
â”œâ”€â”€ requirements.txt
â””â”€â”€ README.md

âš™ï¸ requirements.txt
google-adk
playwright
fastmcp
google-generativeai
cryptography


Install setup:

pip install -r requirements.txt
playwright install chrome

ğŸ” Step 1: Password Encryption Utility (run once)
# encrypt_password.py
from cryptography.fernet import Fernet

# Generate key once
key = Fernet.generate_key()
with open("config/encryption_key.txt", "wb") as f:
    f.write(key)

fernet = Fernet(key)

password = input("Enter password to encrypt: ").strip()
encrypted = fernet.encrypt(password.encode())

with open("secrets/encrypted_password.txt", "wb") as f:
    f.write(encrypted)

print("âœ… Password encrypted and stored securely.")

ğŸ¤– Step 2: Agentic Playwright Tool (tools/agentic_playwright_tool.py)

This is the heart of the system â€” it reads the task, decrypts credentials, reasons about the page, and acts.

from fastmcp import tool
from playwright.sync_api import sync_playwright
import google.generativeai as genai
from cryptography.fernet import Fernet
import os, time, json

SNAPSHOT_DIR = "snapshots"
os.makedirs(SNAPSHOT_DIR, exist_ok=True)

# Configure Gemini reasoning model
genai.configure(api_key=os.environ.get("GOOGLE_API_KEY"))
model = genai.GenerativeModel("gemini-1.5-pro")

def decrypt_password():
    """Decrypt enterprise password from files."""
    key = open("config/encryption_key.txt", "rb").read()
    encrypted = open("secrets/encrypted_password.txt", "rb").read()
    fernet = Fernet(key)
    return fernet.decrypt(encrypted).decode()

@tool("enterprise_browser_tool")
def execute_enterprise_task(task_text: str):
    """
    Fully agentic browser automation based on natural-language task description.
    Steps:
    1. Reads human instructions.
    2. Uses LLM to reason which actions to take (enter text, click, etc.).
    3. Executes all browser operations dynamically with Playwright.
    """
    with sync_playwright() as p:
        browser = p.chromium.launch(headless=False, args=["--start-maximized"])
        page = browser.new_page()

        print("\nğŸ¤– Reading enterprise task...")
        print(task_text)

        # Inject decrypted password
        password = decrypt_password()
        task_text = task_text.replace("{{password}}", password)

        # Step 1: Ask LLM for structured reasoning plan
        planning_prompt = f"""
        You are an enterprise automation agent controlling a Chrome browser.
        Based on the user's instruction below, generate a structured step-by-step plan.
        Each step should include an action type ("go_to", "type", "click", "wait", "screenshot"),
        and a target (preferably by human-readable description, not fixed selectors).

        Instructions:
        {task_text}

        Respond in JSON list format, for example:
        [
            {{"action": "go_to", "target": "https://portal.company.com/login"}},
            {{"action": "type", "target": "user id field", "value": "sunil@company.com"}},
            {{"action": "type", "target": "password field", "value": "myPassword"}},
            {{"action": "click", "target": "Login button"}},
            {{"action": "click", "target": "New Email Registration link"}},
            {{"action": "type", "target": "name field", "value": "Sunil Anikepati"}},
            {{"action": "type", "target": "email field", "value": "sunil@company.com"}},
            {{"action": "type", "target": "department field", "value": "Engineering"}},
            {{"action": "click", "target": "Submit button"}}
        ]
        """
        print("ğŸ§  LLM generating browser plan...")
        reasoning = model.generate_content(planning_prompt)
        plan_text = reasoning.text
        print("ğŸ“œ Plan:", plan_text)

        try:
            plan = json.loads(plan_text)
        except:
            print("âš ï¸ Could not parse plan. Exiting.")
            browser.close()
            return

        # Step 2: Execute plan dynamically
        for step in plan:
            action = step.get("action")
            target = step.get("target", "")
            value = step.get("value", "")

            if action == "go_to":
                page.goto(target, wait_until="domcontentloaded")
                page.screenshot(path=f"{SNAPSHOT_DIR}/step_goto.png")

            elif action == "type":
                # Ask LLM to find the element dynamically from DOM
                dom = page.content()
                reasoning_prompt = f"""
                You are an automation reasoning model.
                Find the best Playwright locator for this description: "{target}".
                Here is partial DOM:
                {dom[:8000]}
                Return JSON: {{"locator_strategy": "text|css|xpath", "locator_value": "..."}}.
                """
                locator_reasoning = model.generate_content(reasoning_prompt)
                try:
                    loc_json = json.loads(locator_reasoning.text)
                except:
                    loc_json = {"locator_strategy": "text", "locator_value": target}

                locator = page.get_by_text(loc_json["locator_value"]) if loc_json["locator_strategy"] == "text" else page.locator(loc_json["locator_value"])
                if locator.count() > 0:
                    locator.first.fill(value)
                    print(f"âŒ¨ï¸ Typed '{value}' into {target}")
                else:
                    print(f"âš ï¸ Could not locate {target}")

            elif action == "click":
                dom = page.content()
                click_prompt = f"""
                You are an automation model.
                Find the clickable element in the DOM corresponding to: "{target}".
                Here is partial DOM:
                {dom[:8000]}
                Return JSON: {{"locator_strategy": "text|css|xpath", "locator_value": "..."}}.
                """
                click_reasoning = model.generate_content(click_prompt)
                try:
                    click_json = json.loads(click_reasoning.text)
                except:
                    click_json = {"locator_strategy": "text", "locator_value": target}

                locator = page.get_by_text(click_json["locator_value"]) if click_json["locator_strategy"] == "text" else page.locator(click_json["locator_value"])
                if locator.count() > 0:
                    locator.first.click()
                    print(f"ğŸ–±ï¸ Clicked on {target}")
                    time.sleep(2)
                    page.screenshot(path=f"{SNAPSHOT_DIR}/after_click_{target.replace(' ', '_')}.png")
                else:
                    print(f"âš ï¸ Could not find element to click: {target}")

            elif action == "wait":
                delay = int(step.get("value", 2))
                print(f"â³ Waiting {delay}s...")
                time.sleep(delay)

            elif action == "screenshot":
                path = f"{SNAPSHOT_DIR}/manual_snapshot_{int(time.time())}.png"
                page.screenshot(path=path)
                print(f"ğŸ“¸ Saved snapshot: {path}")

        browser.close()
        print("âœ… Enterprise automation completed successfully.")

ğŸ§  Step 3: Define Agent (agents/enterprise_agent.py)
from google.adk import Agent
from tools.agentic_playwright_tool import execute_enterprise_task

EnterpriseAgent = Agent(
    name="EnterpriseAutomationAgent",
    description="Understands and executes complex enterprise automation workflows in the browser using reasoning and Playwright.",
    tools=[execute_enterprise_task],
)

ğŸš€ Step 4: Runner (main.py)
import asyncio
from google.adk import Runner
from agents.enterprise_agent import EnterpriseAgent

async def main():
    print("=== ğŸ§  Enterprise Agentic Automation ===")
    with open("config/task_description.txt") as f:
        task_text = f.read().strip()

    runner = Runner(agents=[EnterpriseAgent])
    await runner.run(task_text)
    await runner.destroy(EnterpriseAgent)

if __name__ == "__main__":
    asyncio.run(main())

ğŸ“ Step 5: Task Description (config/task_description.txt)
Go to https://portal.company.com/login, log in using my user ID sunil@company.com and the encrypted password {{password}}, 
decrypt it, enter it, and click the Login button.
After login, click on the "New Email Registration" link and fill the form:
Name: Sunil Anikepati
Email: sunil@company.com
Department: Engineering
Then click Submit and take a screenshot after submission.

âœ… How to Run
export GOOGLE_API_KEY="your-gemini-api-key"
python main.py

ğŸ§© How It Works
Stage	Description
Task Parsing	Reads your natural language file and decrypts password placeholders.
LLM Planning	Gemini creates structured JSON step plan (navigate, type, click).
Dynamic Reasoning	For each step, the agent re-analyzes DOM to find elements â€” no selectors needed.
Execution	Playwright executes each action and takes screenshots.
Autonomy	No user input. Full flow from login â†’ form fill â†’ submit.
ğŸ”’ Enterprise-Grade Features
Feature	Description
ğŸ§  LLM Reasoning	Understands intent dynamically from instructions
ğŸ§© No Hardcoded Selectors	Learns DOM live each time
ğŸ” Encrypted Credentials	Secure password storage and decryption
ğŸ–¼ï¸ Snapshots	Before/after visual logs
ğŸ§¹ Clean Lifecycle	Agent created/destroyed automatically
ğŸ“¦ Extendable
