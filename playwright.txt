# agent.py
import os
from google.adk.agents import LlmAgent, SequentialAgent
from google.adk.tools.mcp_tool.mcp_toolset import MCPToolset
from google.adk.tools.mcp_tool.mcp_session_manager import StdioConnectionParams
from mcp import StdioServerParameters
from pydantic import BaseModel

# Define a tool to get credentials (shared across sub-agents)
class GetCredentialsInput(BaseModel):
    pass  # No input needed

def get_credentials(input: GetCredentialsInput) -> dict:
    """
    Retrieves the username and password for Power Platform login.
    Returns a dictionary with 'username' and 'password'.
    """
    username = os.environ.get("MS_USERNAME", "default_username")
    password = os.environ.get("MS_PASSWORD", "default_password")
    return {"username": username, "password": password}

# Shared MCPToolset instance with increased timeout for connection stability during MFA
mcp_toolset = MCPToolset(
    connection_params=StdioConnectionParams(
        server_params=StdioServerParameters(
            command="npx",
            args=[
                "-y",
                "@playwright/mcp@latest",
                "--headless=false",  # Visible browser
                "--slow-mo=2000",  # Slow down for visibility and pacing
                "--no-sandbox",  # Helps with freezes
                "--disable-gpu",  # Prevents rendering issues
            ],
        ),
        timeout=120,  # Increased timeout (seconds) to prevent "connection closed" during MFA/loads
    ),
    tool_filter=[
        "browser_navigate",
        "browser_click",
        "browser_type",
        "browser_snapshot",
        "browser_wait_for",
        "browser_select_option",
        "browser_press_key",
        "browser_handle_dialog",
        "browser_close",
    ],
)

# Sub-agent 1: Task 1 - Login to Power Platform (enhanced MFA handling)
sub_agent1 = LlmAgent(
    model="gemini-2.0-flash",
    name="task1_login",
    description="Handles Task 1: Login to Power Platform, including MFA wait.",
    instruction="""You are a login automation agent. Execute Task 1 sequentially with tool chaining: Chain browser_navigate to 'https://admin.powerplatform.microsoft.com', wait for load (browser_wait_for body, timeout=30000ms). Chain browser_snapshot to locate login fields. If sign-in prompt, chain get_credentials output to browser_type username into textbox 'Enter your email or phone' (role='textbox', name='Enter your email or phone'), then browser_click 'Next' (role='button', name='Next'). For MFA, chain browser_wait_for (timeout=120000ms) to allow manual mobile entry; during wait, take periodic snapshots (every 10s) to log progress. After wait, check multiple conditions: URL containing '/home', OR presence of 'Manage users, environments' tab (role='tab', name='Manage users, environments'), OR dashboard elements like navigation pane. If not met, retry wait up to 60s more. Delay 5000ms after each action. Snapshot to confirm home page. If element not found, scroll (browser_press_key 'PageDown', count=5), resnapshot, retry up to 5 times.
Output "Task 1 completed" upon success.
Start upon input.""",
    tools=[get_credentials, mcp_toolset],
)

# Sub-agent 2: Task 2 - Create Parent Business Unit
sub_agent2 = LlmAgent(
    model="gemini-2.0-flash",
    name="task2_create_parent_bu",
    description="Handles Task 2: Create Parent Business Unit.",
    instruction="""You are a business unit creation agent. Execute Task 2 using existing browser context: Chain browser_snapshot to locate and browser_click 'Manage' tab link (role='button' or 'link' or 'tab', name='Manage' on left panel). Wait for load (browser_wait_for environments list). Chain to click 'Environments' link (role='link', name='Environments'), wait for table. Chain snapshot to locate and click 'WIM OPS POC' in environments table (role='row' or 'link', name='WIM OPS POC'). Wait for right panel load. Chain to click 'See all' under Business units (role='link', name='See all'). Wait for page load. Chain to click '+ New Business Unit' (role='button' or 'link', name='+ New Business Unit'). Chain snapshot to locate textbox 'Name' (role='textbox', name='Name'), type 'COO TEST SUNIL'. Chain to click 'Save' (role='button', name='Save'). Wait for popup close (browser_wait_for absence of pane, timeout=30000ms). Delay 5000ms after each action. Snapshot to confirm creation. Retry with scroll/resnapshot if needed.
Output "Task 2 completed" upon success.
Start upon input.""",
    tools=[mcp_toolset],
)

# Sub-agent 3: Task 3 - Create Child Business Unit
sub_agent3 = LlmAgent(
    model="gemini-2.0-flash",
    name="task3_create_child_bu",
    description="Handles Task 3: Create Child Business Unit.",
    instruction="""You are a business unit creation agent. Execute Task 3 using existing browser context: Chain browser_snapshot to click 'Manage' tab link (role='button' or 'link' or 'tab', name='Manage'). Wait for load. Chain to click 'Environments' link, wait for table. Chain to click 'WIM OPS POC'. Wait for panel. Chain to click 'See all' under Business units. Wait for load. Chain to click '+ New Business Unit'. Chain snapshot to textbox 'Name', type 'COO TEST SUNIL CHILD'. Chain to combobox 'Parent business unit' (role='combobox', name='Parent business unit'), type 'COO TEST SUNIL', select matching option (browser_select_option or click). Chain to click 'Save'. Wait for close. Delay 5000ms after actions. Snapshot confirmation. Retry with scroll/resnapshot.
Output "Task 3 completed" upon success.
Start upon input.""",
    tools=[mcp_toolset],
)

# Sub-agent 4: Task 4 - Create Team
sub_agent4 = LlmAgent(
    model="gemini-2.0-flash",
    name="task4_create_team",
    description="Handles Task 4: Create Team.",
    instruction="""You are a team creation agent. Execute Task 4 using existing browser context: Chain browser_snapshot to click 'Manage' tab. Wait. Chain to click 'Environments', wait for table. Chain to click 'WIM OPS POC'. Wait. Chain to click 'See all' under Teams (role='link', name='See all'). Wait for load. Chain to click '+ Create team' (role='button' or 'link', name='+ Create team'). Chain snapshot to textbox 'Team name' (role='textbox', name='Team name'), type 'SUNIL TEAM'. Chain to combobox 'Business Unit' (role='combobox', name='Business Unit'), type 'COO TEST SUNIL CHILD', select autocomplete option. Chain to combobox 'Administrator', type 'SUNIL ANIKEPATI', select. Chain to select 'Owner' for Team Type (role='option' or combobox, name='Team Type'). Chain to save/create button. Wait for completion. Delay 5000ms after actions. Snapshot confirmation. Retry with scroll/resnapshot.
Output "Task 4 completed" and chain browser_close at end.
Start upon input.""",
    tools=[mcp_toolset],
)

# Compose into SequentialAgent for sequential execution without losing browser context
sequential_agent = SequentialAgent(
    name="power_platform_automator",
    description="Executes 4 tasks sequentially in Power Platform using shared browser.",
    sub_agents=[sub_agent1, sub_agent2, sub_agent3, sub_agent4],  # Runs one by one, sharing MCPToolset browser
)

# Main agent to trigger on "create smart mailbox" prompt
main_agent = LlmAgent(
    model="gemini-2.0-flash",
    name="smart_mailbox_trigger",
    description="Triggers the smart mailbox automation flow.",
    instruction="""If the user prompt contains 'create smart mailbox', immediately start the sequential_agent chain for the 4 tasks. Otherwise, respond with 'Please say "create smart mailbox" to begin automation.' Output status updates after each task.""",
    tools=[sequential_agent],  # Wrap SequentialAgent as a tool for chaining
)

# agent.py
import os
from google.adk.agents import LlmAgent
from google.adk.tools.mcp_tool.mcp_toolset import MCPToolset
from google.adk.tools.mcp_tool.mcp_session_manager import StdioConnectionParams
from mcp import StdioServerParameters
from pydantic import BaseModel, Field

# Define a tool to get credentials
class GetCredentialsInput(BaseModel):
    pass  # No input needed

def get_credentials(input: GetCredentialsInput) -> dict:
    """
    Retrieves the username and password for Microsoft admin login.
    Returns a dictionary with 'username' and 'password'.
    """
    username = os.environ.get("MS_USERNAME", "")  # Default to provided email
    password = os.environ.get("MS_PASSWORD", "default_password")  # Set via environment variable
    return {"username": username, "password": password}

# URLs as constants
POWER_PLATFORM_URL = "https://admin.powerplatform.microsoft.com/"
M365_ADMIN_URL = "https://admin.microsoft.com/"

root_agent = LlmAgent(
    model="gemini-2.0-flash",  # Use the latest Gemini model available in ADK
    name="dynamics_automator",
    description="An AI agent that automates the creation of business units, teams, shared mailbox, and queue in Microsoft Dynamics 365 and Microsoft 365 using browser automation tools.",
    instruction="""
You are an enterprise-grade automation agent for setting up Microsoft Dynamics 365 smart mailbox with business units and teams. Your goal is to automate the task using natural language processing of the steps, reliably, ensuring execution at any cost by incorporating resilience strategies. Use up to 10 retries for any failed action. Always use stable selectors like role='textbox' with name, role='button' with name, etc., from snapshots.

Task steps in natural language:
Natural language task steps:
1. Navigate to 'https://admin.powerplatform.microsoft.com'. Wait for load.
2. Click textbox 'Enter your email or phone', fill with username from get_credentials, click 'Next'.
3. For MFA, wait 120s for manual approval, then wait for URL '/home'.
4. Click tab 'Manage users, environments'.
5. Click link 'WIM OPS POC', wait for URL matching '/manage/environments/environment.*'.
6. Click link 'See all Business units'.
7. Click menuitem 'New business unit'.
8. Click textbox 'Name *', fill 'COO O2A PARENT DEMO557'.
9. Click button 'Save', wait 2000ms.
10. Click 'New business unit' again.
11. Click textbox 'Name *', fill 'COO O2A CHILD DEMO557'.
12. Click button 'Cancel wimopspoc' if present (or handle dialog).
13. Click combobox 'Parent business unit dropdown', fill 'COO', click option 'COO O2A PARENT DEMO'.
14. Click 'Save', wait 2000ms.
15. Click tab 'Manage users, environments'.
16. Click 'WIM OPS POC'.
17. Click link 'See all Teams'.
18. Click menuitem 'Create team'.
19. Click textbox 'Team name *', fill 'COO O2A TEAMS DEMO557'.
20. Click textbox 'Description', fill 'Test demo descript'.
21. Click combobox 'Business unit', fill 'COO', click option 'COO O2A CHILD DEMO557'.
22. Wait 2000ms.
23. Click combobox 'Administrator', fill 'MTC', click option 'Mitchell Jones'.
24. Click option 'Microsoft Entra ID Security'.
25. Click combobox 'People Picker', fill 'ctc', click option 'DTCA CFG Dynamics365_S MMS_TEST'.
26. Click text 'Members and guests'.
27. Click option 'Owners'.
28. Click button 'Next'.
29. Complete any remaining steps for team save/creation.
30. If needed, proceed to shared mailbox in M365 admin (navigate to 'https://admin.microsoft.com', handle login/MFA, create 'Smart Mailbox', add members, block sign-in).
31. Back to Power Platform, create queue 'Smart Queue' with shared mailbox email, owner as new team.
32. Approve and enable mailbox, confirm success.
33. Output "Task completed successfully." and close browser only at end.

Use browser_snapshot to locate elements by role and name (e.g., role='textbox', name='Name *'). Before interactions, confirm presence. For fails, retry with wait, scroll ('PageDown' x5), resnapshot.
Handle dialogs. Use browser_wait_for for loads/timeouts. For combos, use browser_type then browser_click option.
Start upon 'Start automation'.

Enhanced Resilience:
- Use browser_snapshot before each interaction to find exact refs, use role and name selectors as in the code (e.g., getByRole('textbox', {name: 'Name *'})).
- For MFA and loads, use long timeouts.
- Retry with scroll, wait, refresh if element not found.
- Handle dialogs, verify post-action states.

Start the task immediately upon receiving the user prompt "Start automation".
""",
    tools=[
        get_credentials,
        MCPToolset(
            connection_params=StdioConnectionParams(
                server_params=StdioServerParameters(
                    command="npx",
                    args=[
                        "-y",
                        "@playwright/mcp@latest",
                        "--headless=false",
                        "--slow-mo=1000",
                    ],
                ),
            ),
            tool_filter=[
                "browser_navigate",
                "browser_click",
                "browser_type",
                "browser_snapshot",
                "browser_wait_for",
                "browser_select_option",
                "browser_press_key",
                "browser_handle_dialog",
                "browser_close",
            ],
        ),
    ],
)

# run_automation.py (for running the agent asynchronously, modular runner)
import asyncio
import os
from dotenv import load_dotenv
from google.genai import types
from google.adk.agents.llm_agent import LlmAgent
from google.adk.runners import Runner
from google.adk.sessions import InMemorySessionService
from google.adk.artifacts.in_memory_artifact_service import InMemoryArtifactService
from multi_tool_agent.agent import root_agent, MCPToolset  # Adjust import based on your folder structure

load_dotenv()  # Load environment variables for credentials

async def async_main():
    session_service = InMemorySessionService()
    artifacts_service = InMemoryArtifactService()
    session = await session_service.create_session(state={}, app_name='dynamics_automator', user_id='automation_user')
    
    # Prompt to start the automation
    query = "Start automation"
    content = types.Content(role='user', parts=[types.Part(text=query)])
    
    # Assuming root_agent is defined synchronously; for async tools like MCP, manage cleanup
    toolset = root_agent.tools[1]  # The MCPToolset instance
    runner = Runner(app_name='dynamics_automator', agent=root_agent, artifact_service=artifacts_service, session_service=session_service)
    
    async for event in runner.run_async(session_id=session.id, user_id=session.user_id, new_message=content):
        print(f"Event received: {event}")
    
    # Cleanup
    await toolset.close()

if __name__ == '__main__':
    asyncio.run(async_main())

system ğŸ§ ğŸ’¼
Youâ€™ll simply run python main.py, and the agent will read a natural language enterprise task description (like a paragraph of instructions), interpret it, reason about what to do, decrypt credentials, and perform the full workflow automatically inside Chrome.

ğŸ¯ Your Use Case

You want to describe everything in natural language once â€” e.g.:

Go to https://portal.company.com/login, log in using my user ID sunil@company.com and the encrypted password below, decrypt it, enter it, click Login. 
After login, click on the 'New Email Registration' link, fill in the form with name Sunil Anikepati, email sunil@company.com, department Engineering, and submit the form.


The system will:

Parse & understand this natural text (via LLM reasoning),

Decrypt the password (using cryptography.Fernet),

Execute all browser actions with Playwright,

Behave like a human â€” dynamic DOM understanding, no fixed selectors,

Take before/after snapshots,

Run entirely autonomously (no user input).

ğŸ§© Project Structure
enterprise_agentic_browser/
â”‚
â”œâ”€â”€ main.py
â”œâ”€â”€ agents/
â”‚   â””â”€â”€ enterprise_agent.py
â”œâ”€â”€ tools/
â”‚   â””â”€â”€ agentic_playwright_tool.py
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ task_description.txt      # Your full natural language task
â”‚   â””â”€â”€ encryption_key.txt        # Encryption key for password decryption
â”œâ”€â”€ secrets/
â”‚   â””â”€â”€ encrypted_password.txt    # Encrypted password file
â”œâ”€â”€ requirements.txt
â””â”€â”€ README.md

âš™ï¸ requirements.txt
google-adk
playwright
fastmcp
google-generativeai
cryptography


Install setup:

pip install -r requirements.txt
playwright install chrome

ğŸ” Step 1: Password Encryption Utility (run once)
# encrypt_password.py
from cryptography.fernet import Fernet

# Generate key once
key = Fernet.generate_key()
with open("config/encryption_key.txt", "wb") as f:
    f.write(key)

fernet = Fernet(key)

password = input("Enter password to encrypt: ").strip()
encrypted = fernet.encrypt(password.encode())

with open("secrets/encrypted_password.txt", "wb") as f:
    f.write(encrypted)

print("âœ… Password encrypted and stored securely.")

ğŸ¤– Step 2: Agentic Playwright Tool (tools/agentic_playwright_tool.py)

This is the heart of the system â€” it reads the task, decrypts credentials, reasons about the page, and acts.

from fastmcp import tool
from playwright.sync_api import sync_playwright
import google.generativeai as genai
from cryptography.fernet import Fernet
import os, time, json

SNAPSHOT_DIR = "snapshots"
os.makedirs(SNAPSHOT_DIR, exist_ok=True)

# Configure Gemini reasoning model
genai.configure(api_key=os.environ.get("GOOGLE_API_KEY"))
model = genai.GenerativeModel("gemini-1.5-pro")

def decrypt_password():
    """Decrypt enterprise password from files."""
    key = open("config/encryption_key.txt", "rb").read()
    encrypted = open("secrets/encrypted_password.txt", "rb").read()
    fernet = Fernet(key)
    return fernet.decrypt(encrypted).decode()

@tool("enterprise_browser_tool")
def execute_enterprise_task(task_text: str):
    """
    Fully agentic browser automation based on natural-language task description.
    Steps:
    1. Reads human instructions.
    2. Uses LLM to reason which actions to take (enter text, click, etc.).
    3. Executes all browser operations dynamically with Playwright.
    """
    with sync_playwright() as p:
        browser = p.chromium.launch(headless=False, args=["--start-maximized"])
        page = browser.new_page()

        print("\nğŸ¤– Reading enterprise task...")
        print(task_text)

        # Inject decrypted password
        password = decrypt_password()
        task_text = task_text.replace("{{password}}", password)

        # Step 1: Ask LLM for structured reasoning plan
        planning_prompt = f"""
        You are an enterprise automation agent controlling a Chrome browser.
        Based on the user's instruction below, generate a structured step-by-step plan.
        Each step should include an action type ("go_to", "type", "click", "wait", "screenshot"),
        and a target (preferably by human-readable description, not fixed selectors).

        Instructions:
        {task_text}

        Respond in JSON list format, for example:
        [
            {{"action": "go_to", "target": "https://portal.company.com/login"}},
            {{"action": "type", "target": "user id field", "value": "sunil@company.com"}},
            {{"action": "type", "target": "password field", "value": "myPassword"}},
            {{"action": "click", "target": "Login button"}},
            {{"action": "click", "target": "New Email Registration link"}},
            {{"action": "type", "target": "name field", "value": "Sunil Anikepati"}},
            {{"action": "type", "target": "email field", "value": "sunil@company.com"}},
            {{"action": "type", "target": "department field", "value": "Engineering"}},
            {{"action": "click", "target": "Submit button"}}
        ]
        """
        print("ğŸ§  LLM generating browser plan...")
        reasoning = model.generate_content(planning_prompt)
        plan_text = reasoning.text
        print("ğŸ“œ Plan:", plan_text)

        try:
            plan = json.loads(plan_text)
        except:
            print("âš ï¸ Could not parse plan. Exiting.")
            browser.close()
            return

        # Step 2: Execute plan dynamically
        for step in plan:
            action = step.get("action")
            target = step.get("target", "")
            value = step.get("value", "")

            if action == "go_to":
                page.goto(target, wait_until="domcontentloaded")
                page.screenshot(path=f"{SNAPSHOT_DIR}/step_goto.png")

            elif action == "type":
                # Ask LLM to find the element dynamically from DOM
                dom = page.content()
                reasoning_prompt = f"""
                You are an automation reasoning model.
                Find the best Playwright locator for this description: "{target}".
                Here is partial DOM:
                {dom[:8000]}
                Return JSON: {{"locator_strategy": "text|css|xpath", "locator_value": "..."}}.
                """
                locator_reasoning = model.generate_content(reasoning_prompt)
                try:
                    loc_json = json.loads(locator_reasoning.text)
                except:
                    loc_json = {"locator_strategy": "text", "locator_value": target}

                locator = page.get_by_text(loc_json["locator_value"]) if loc_json["locator_strategy"] == "text" else page.locator(loc_json["locator_value"])
                if locator.count() > 0:
                    locator.first.fill(value)
                    print(f"âŒ¨ï¸ Typed '{value}' into {target}")
                else:
                    print(f"âš ï¸ Could not locate {target}")

            elif action == "click":
                dom = page.content()
                click_prompt = f"""
                You are an automation model.
                Find the clickable element in the DOM corresponding to: "{target}".
                Here is partial DOM:
                {dom[:8000]}
                Return JSON: {{"locator_strategy": "text|css|xpath", "locator_value": "..."}}.
                """
                click_reasoning = model.generate_content(click_prompt)
                try:
                    click_json = json.loads(click_reasoning.text)
                except:
                    click_json = {"locator_strategy": "text", "locator_value": target}

                locator = page.get_by_text(click_json["locator_value"]) if click_json["locator_strategy"] == "text" else page.locator(click_json["locator_value"])
                if locator.count() > 0:
                    locator.first.click()
                    print(f"ğŸ–±ï¸ Clicked on {target}")
                    time.sleep(2)
                    page.screenshot(path=f"{SNAPSHOT_DIR}/after_click_{target.replace(' ', '_')}.png")
                else:
                    print(f"âš ï¸ Could not find element to click: {target}")

            elif action == "wait":
                delay = int(step.get("value", 2))
                print(f"â³ Waiting {delay}s...")
                time.sleep(delay)

            elif action == "screenshot":
                path = f"{SNAPSHOT_DIR}/manual_snapshot_{int(time.time())}.png"
                page.screenshot(path=path)
                print(f"ğŸ“¸ Saved snapshot: {path}")

        browser.close()
        print("âœ… Enterprise automation completed successfully.")

ğŸ§  Step 3: Define Agent (agents/enterprise_agent.py)
from google.adk import Agent
from tools.agentic_playwright_tool import execute_enterprise_task

EnterpriseAgent = Agent(
    name="EnterpriseAutomationAgent",
    description="Understands and executes complex enterprise automation workflows in the browser using reasoning and Playwright.",
    tools=[execute_enterprise_task],
)

ğŸš€ Step 4: Runner (main.py)
import asyncio
from google.adk import Runner
from agents.enterprise_agent import EnterpriseAgent

async def main():
    print("=== ğŸ§  Enterprise Agentic Automation ===")
    with open("config/task_description.txt") as f:
        task_text = f.read().strip()

    runner = Runner(agents=[EnterpriseAgent])
    await runner.run(task_text)
    await runner.destroy(EnterpriseAgent)

if __name__ == "__main__":
    asyncio.run(main())

ğŸ“ Step 5: Task Description (config/task_description.txt)
Go to https://portal.company.com/login, log in using my user ID sunil@company.com and the encrypted password {{password}}, 
decrypt it, enter it, and click the Login button.
After login, click on the "New Email Registration" link and fill the form:
Name: Sunil Anikepati
Email: sunil@company.com
Department: Engineering
Then click Submit and take a screenshot after submission.

âœ… How to Run
export GOOGLE_API_KEY="your-gemini-api-key"
python main.py

ğŸ§© How It Works
Stage	Description
Task Parsing	Reads your natural language file and decrypts password placeholders.
LLM Planning	Gemini creates structured JSON step plan (navigate, type, click).
Dynamic Reasoning	For each step, the agent re-analyzes DOM to find elements â€” no selectors needed.
Execution	Playwright executes each action and takes screenshots.
Autonomy	No user input. Full flow from login â†’ form fill â†’ submit.
ğŸ”’ Enterprise-Grade Features
Feature	Description
ğŸ§  LLM Reasoning	Understands intent dynamically from instructions
ğŸ§© No Hardcoded Selectors	Learns DOM live each time
ğŸ” Encrypted Credentials	Secure password storage and decryption
ğŸ–¼ï¸ Snapshots	Before/after visual logs
ğŸ§¹ Clean Lifecycle	Agent created/destroyed automatically
ğŸ“¦ Extendable
