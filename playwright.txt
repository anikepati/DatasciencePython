# agent.py
import os
from google.adk.agents import LlmAgent
from google.adk.tools.mcp_tool.mcp_toolset import MCPToolset
from google.adk.tools.mcp_tool.mcp_session_manager import StdioConnectionParams
from mcp import StdioServerParameters
from pydantic import BaseModel, Field

# Define a tool to get credentials
class GetCredentialsInput(BaseModel):
    pass  # No input needed

def get_credentials(input: GetCredentialsInput) -> dict:
    """
    Retrieves the username and password for the enterprise portal login.
    Returns a dictionary with 'username' and 'password'.
    """
    username = os.environ.get("PORTAL_USERNAME", "default_username")  # Set via environment variable
    password = os.environ.get("PORTAL_PASSWORD", "default_password")  # Set via environment variable
    return {"username": username, "password": password}

# The portal URL as a constant (replace with actual URL)
PORTAL_URL = "https://example.com/enterprise-portal"  # Placeholder: Replace with the actual portal URL

root_agent = LlmAgent(
    model="gemini-2.0-flash",  # Use the latest Gemini model available in ADK
    name="enterprise_portal_automator",
    description="An AI agent that automates navigation and business unit creation in the enterprise portal using browser automation tools.",
    instruction="""
You are an enterprise-grade automation agent for managing tasks in the enterprise portal. Your goal is to automate the following task reliably, ensuring execution at any cost by incorporating resilience strategies. Use up to 5 retries for any failed action (e.g., if an element is not found or click fails, inspect the page again with browser_snapshot, scroll, wait, and retry). Always prioritize resilient practices: use stable selectors like text-based or role-based from snapshots, auto-wait with browser_wait_for before interactions, verify page state after actions.

Task steps:
1. Open the enterprise portal by navigating to {portal_url}. After navigation, use browser_wait_for to ensure the page is loaded (e.g., wait for body or a key element), then snapshot to confirm.
2. If a sign-in prompt appears (check snapshot for login fields), use the get_credentials tool to obtain the username and password, fill them in the appropriate fields (use browser_type), and click 'Sign In' or 'Next'. If MFA or captcha appears, note it but proceed if possible; retry if fails.
3. After login, wait for dashboard load, snapshot, and click 'Manage'. Verify post-click with another snapshot.
4. In the environment list, locate and select the environment named "ABC OPS POC" (prefer text selector). If not visible, scroll down using browser_press_key ('PageDown', count=5), resnapshot, retry up to 5 times.
5. Click the 'See all' link under the Business Unit section on the right. If not visible, scroll (browser_press_key 'ArrowDown' or 'PageDown' multiple times, e.g., count=10), wait for potential loading (browser_wait_for selector if spinner exists), resnapshot, and retry up to 5 times. Handle if section loads asynchronously.
6. Click on "+ New Business Unit". Wait for pane (browser_wait_for).
7. Wait for the new business unit pane to load fully (browser_wait_for input fields).
8. Fill in the name field with "ANIKES TEST ABC" (browser_type).
9. Click on 'Save'. Handle any confirmation dialogs with browser_handle_dialog.
10. After save, snapshot to locate the new business unit link, click it. If not immediate, wait and resnapshot.
11. Confirm that the Business Unit page is visible by checking the page content with browser_snapshot (look for expected title or elements).

Resilience strategies:
- Before every interaction (click, type), take a browser_snapshot to get the latest refs and confirm element presence/visibility.
- Use browser_wait_for liberally: for selectors like {role: 'button', name: 'Manage'}, or for absence of loading spinners.
- If element not found, retry sequence: wait 2-5s (browser_wait_for timeout), scroll (press_key 'PageDown' 3-5 times), resnapshot.
- Describe elements human-readably in 'element' but use exact 'ref' from snapshot for actions.
- Handle unexpected states: if dialog appears, use browser_handle_dialog (accept if confirmation).
- After major actions (navigate, click leading to load), verify with snapshot that expected content is present; if not, backtrack or retry.
- If network issues or timeouts, retry the action up to 5 times with increasing waits.
- Run cautiously to avoid infinite loops; after 5 retries per step, log failure but proceed to next if possible.

Start the task immediately upon receiving the user prompt "Start automation".
""".format(portal_url=PORTAL_URL),
    tools=[
        get_credentials,  # Add the credentials tool
        MCPToolset(
            connection_params=StdioConnectionParams(
                server_params=StdioServerParameters(
                    command="npx",
                    args=[
                        "-y",
                        "@playwright/mcp@latest",
                        # Add options for visible browser and slower execution for resilience
                        "--headless=false",  # Run headed for visual debugging
                        "--slow-mo=500",  # Slow down actions by 500ms for better handling of async loads
                    ],
                ),
            ),
            # Expand tool_filter to include more for resilience if needed, but stick to essentials
            tool_filter=[
                "browser_navigate",
                "browser_click",
                "browser_type",
                "browser_snapshot",
                "browser_wait_for",
                "browser_select_option",
                "browser_press_key",
                "browser_handle_dialog",
                "browser_close",
            ],
        ),
    ],
)

system ğŸ§ ğŸ’¼
Youâ€™ll simply run python main.py, and the agent will read a natural language enterprise task description (like a paragraph of instructions), interpret it, reason about what to do, decrypt credentials, and perform the full workflow automatically inside Chrome.

ğŸ¯ Your Use Case

You want to describe everything in natural language once â€” e.g.:

Go to https://portal.company.com/login, log in using my user ID sunil@company.com and the encrypted password below, decrypt it, enter it, click Login. 
After login, click on the 'New Email Registration' link, fill in the form with name Sunil Anikepati, email sunil@company.com, department Engineering, and submit the form.


The system will:

Parse & understand this natural text (via LLM reasoning),

Decrypt the password (using cryptography.Fernet),

Execute all browser actions with Playwright,

Behave like a human â€” dynamic DOM understanding, no fixed selectors,

Take before/after snapshots,

Run entirely autonomously (no user input).

ğŸ§© Project Structure
enterprise_agentic_browser/
â”‚
â”œâ”€â”€ main.py
â”œâ”€â”€ agents/
â”‚   â””â”€â”€ enterprise_agent.py
â”œâ”€â”€ tools/
â”‚   â””â”€â”€ agentic_playwright_tool.py
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ task_description.txt      # Your full natural language task
â”‚   â””â”€â”€ encryption_key.txt        # Encryption key for password decryption
â”œâ”€â”€ secrets/
â”‚   â””â”€â”€ encrypted_password.txt    # Encrypted password file
â”œâ”€â”€ requirements.txt
â””â”€â”€ README.md

âš™ï¸ requirements.txt
google-adk
playwright
fastmcp
google-generativeai
cryptography


Install setup:

pip install -r requirements.txt
playwright install chrome

ğŸ” Step 1: Password Encryption Utility (run once)
# encrypt_password.py
from cryptography.fernet import Fernet

# Generate key once
key = Fernet.generate_key()
with open("config/encryption_key.txt", "wb") as f:
    f.write(key)

fernet = Fernet(key)

password = input("Enter password to encrypt: ").strip()
encrypted = fernet.encrypt(password.encode())

with open("secrets/encrypted_password.txt", "wb") as f:
    f.write(encrypted)

print("âœ… Password encrypted and stored securely.")

ğŸ¤– Step 2: Agentic Playwright Tool (tools/agentic_playwright_tool.py)

This is the heart of the system â€” it reads the task, decrypts credentials, reasons about the page, and acts.

from fastmcp import tool
from playwright.sync_api import sync_playwright
import google.generativeai as genai
from cryptography.fernet import Fernet
import os, time, json

SNAPSHOT_DIR = "snapshots"
os.makedirs(SNAPSHOT_DIR, exist_ok=True)

# Configure Gemini reasoning model
genai.configure(api_key=os.environ.get("GOOGLE_API_KEY"))
model = genai.GenerativeModel("gemini-1.5-pro")

def decrypt_password():
    """Decrypt enterprise password from files."""
    key = open("config/encryption_key.txt", "rb").read()
    encrypted = open("secrets/encrypted_password.txt", "rb").read()
    fernet = Fernet(key)
    return fernet.decrypt(encrypted).decode()

@tool("enterprise_browser_tool")
def execute_enterprise_task(task_text: str):
    """
    Fully agentic browser automation based on natural-language task description.
    Steps:
    1. Reads human instructions.
    2. Uses LLM to reason which actions to take (enter text, click, etc.).
    3. Executes all browser operations dynamically with Playwright.
    """
    with sync_playwright() as p:
        browser = p.chromium.launch(headless=False, args=["--start-maximized"])
        page = browser.new_page()

        print("\nğŸ¤– Reading enterprise task...")
        print(task_text)

        # Inject decrypted password
        password = decrypt_password()
        task_text = task_text.replace("{{password}}", password)

        # Step 1: Ask LLM for structured reasoning plan
        planning_prompt = f"""
        You are an enterprise automation agent controlling a Chrome browser.
        Based on the user's instruction below, generate a structured step-by-step plan.
        Each step should include an action type ("go_to", "type", "click", "wait", "screenshot"),
        and a target (preferably by human-readable description, not fixed selectors).

        Instructions:
        {task_text}

        Respond in JSON list format, for example:
        [
            {{"action": "go_to", "target": "https://portal.company.com/login"}},
            {{"action": "type", "target": "user id field", "value": "sunil@company.com"}},
            {{"action": "type", "target": "password field", "value": "myPassword"}},
            {{"action": "click", "target": "Login button"}},
            {{"action": "click", "target": "New Email Registration link"}},
            {{"action": "type", "target": "name field", "value": "Sunil Anikepati"}},
            {{"action": "type", "target": "email field", "value": "sunil@company.com"}},
            {{"action": "type", "target": "department field", "value": "Engineering"}},
            {{"action": "click", "target": "Submit button"}}
        ]
        """
        print("ğŸ§  LLM generating browser plan...")
        reasoning = model.generate_content(planning_prompt)
        plan_text = reasoning.text
        print("ğŸ“œ Plan:", plan_text)

        try:
            plan = json.loads(plan_text)
        except:
            print("âš ï¸ Could not parse plan. Exiting.")
            browser.close()
            return

        # Step 2: Execute plan dynamically
        for step in plan:
            action = step.get("action")
            target = step.get("target", "")
            value = step.get("value", "")

            if action == "go_to":
                page.goto(target, wait_until="domcontentloaded")
                page.screenshot(path=f"{SNAPSHOT_DIR}/step_goto.png")

            elif action == "type":
                # Ask LLM to find the element dynamically from DOM
                dom = page.content()
                reasoning_prompt = f"""
                You are an automation reasoning model.
                Find the best Playwright locator for this description: "{target}".
                Here is partial DOM:
                {dom[:8000]}
                Return JSON: {{"locator_strategy": "text|css|xpath", "locator_value": "..."}}.
                """
                locator_reasoning = model.generate_content(reasoning_prompt)
                try:
                    loc_json = json.loads(locator_reasoning.text)
                except:
                    loc_json = {"locator_strategy": "text", "locator_value": target}

                locator = page.get_by_text(loc_json["locator_value"]) if loc_json["locator_strategy"] == "text" else page.locator(loc_json["locator_value"])
                if locator.count() > 0:
                    locator.first.fill(value)
                    print(f"âŒ¨ï¸ Typed '{value}' into {target}")
                else:
                    print(f"âš ï¸ Could not locate {target}")

            elif action == "click":
                dom = page.content()
                click_prompt = f"""
                You are an automation model.
                Find the clickable element in the DOM corresponding to: "{target}".
                Here is partial DOM:
                {dom[:8000]}
                Return JSON: {{"locator_strategy": "text|css|xpath", "locator_value": "..."}}.
                """
                click_reasoning = model.generate_content(click_prompt)
                try:
                    click_json = json.loads(click_reasoning.text)
                except:
                    click_json = {"locator_strategy": "text", "locator_value": target}

                locator = page.get_by_text(click_json["locator_value"]) if click_json["locator_strategy"] == "text" else page.locator(click_json["locator_value"])
                if locator.count() > 0:
                    locator.first.click()
                    print(f"ğŸ–±ï¸ Clicked on {target}")
                    time.sleep(2)
                    page.screenshot(path=f"{SNAPSHOT_DIR}/after_click_{target.replace(' ', '_')}.png")
                else:
                    print(f"âš ï¸ Could not find element to click: {target}")

            elif action == "wait":
                delay = int(step.get("value", 2))
                print(f"â³ Waiting {delay}s...")
                time.sleep(delay)

            elif action == "screenshot":
                path = f"{SNAPSHOT_DIR}/manual_snapshot_{int(time.time())}.png"
                page.screenshot(path=path)
                print(f"ğŸ“¸ Saved snapshot: {path}")

        browser.close()
        print("âœ… Enterprise automation completed successfully.")

ğŸ§  Step 3: Define Agent (agents/enterprise_agent.py)
from google.adk import Agent
from tools.agentic_playwright_tool import execute_enterprise_task

EnterpriseAgent = Agent(
    name="EnterpriseAutomationAgent",
    description="Understands and executes complex enterprise automation workflows in the browser using reasoning and Playwright.",
    tools=[execute_enterprise_task],
)

ğŸš€ Step 4: Runner (main.py)
import asyncio
from google.adk import Runner
from agents.enterprise_agent import EnterpriseAgent

async def main():
    print("=== ğŸ§  Enterprise Agentic Automation ===")
    with open("config/task_description.txt") as f:
        task_text = f.read().strip()

    runner = Runner(agents=[EnterpriseAgent])
    await runner.run(task_text)
    await runner.destroy(EnterpriseAgent)

if __name__ == "__main__":
    asyncio.run(main())

ğŸ“ Step 5: Task Description (config/task_description.txt)
Go to https://portal.company.com/login, log in using my user ID sunil@company.com and the encrypted password {{password}}, 
decrypt it, enter it, and click the Login button.
After login, click on the "New Email Registration" link and fill the form:
Name: Sunil Anikepati
Email: sunil@company.com
Department: Engineering
Then click Submit and take a screenshot after submission.

âœ… How to Run
export GOOGLE_API_KEY="your-gemini-api-key"
python main.py

ğŸ§© How It Works
Stage	Description
Task Parsing	Reads your natural language file and decrypts password placeholders.
LLM Planning	Gemini creates structured JSON step plan (navigate, type, click).
Dynamic Reasoning	For each step, the agent re-analyzes DOM to find elements â€” no selectors needed.
Execution	Playwright executes each action and takes screenshots.
Autonomy	No user input. Full flow from login â†’ form fill â†’ submit.
ğŸ”’ Enterprise-Grade Features
Feature	Description
ğŸ§  LLM Reasoning	Understands intent dynamically from instructions
ğŸ§© No Hardcoded Selectors	Learns DOM live each time
ğŸ” Encrypted Credentials	Secure password storage and decryption
ğŸ–¼ï¸ Snapshots	Before/after visual logs
ğŸ§¹ Clean Lifecycle	Agent created/destroyed automatically
ğŸ“¦ Extendable
