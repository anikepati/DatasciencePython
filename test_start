import os
import logging
import time
import json
import uuid
import pandas as pd
import atexit
from typing import Any, Dict, Optional, List, Callable
from functools import wraps
from retry import retry
import certifi
import phoenix as px
from opentelemetry import trace
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.trace import SpanKind, StatusCode, get_current_span
from openinference.instrumentation.openai import OpenAIInstrumentor
from rouge_score import rouge_scorer
import inspect

# Import the high-level register function, which is the stable entry point.
from phoenix.otel import register

from phoenix.trace import SpanEvaluations
from phoenix.evals import (
    HallucinationEvaluator,
    QAEvaluator,
    RelevanceEvaluator,
)

# Structured logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(name)s: %(message)s',
)
logger = logging.getLogger(__name__)

class GenAIObserver:
    _instance = None
    _instrumented = False

    def __new__(cls, *args, **kwargs):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance.__initialized = False
        return cls._instance

    def __init__(
        self,
        project_name: str = "gen-ai-observability",
        endpoint: Optional[str] = None,
        use_ax_mode: bool = False,
    ):
        if self.__initialized:
            return

        self.project_name = project_name
        self.endpoint = endpoint or os.getenv("PHOENIX_COLLECTOR_ENDPOINT", "http://localhost:6006")
        self.use_ax_mode = use_ax_mode
        self.tracer = trace.get_tracer(__name__)
        self.tracer_provider: Optional[TracerProvider] = None

        self._setup()
        self.__initialized = True
        
        atexit.register(self.shutdown)

    def _setup(self):
        """
        Initializes Phoenix, handling secure (default), custom SSL, and insecure connections.
        """
        if GenAIObserver._instrumented:
            return

        try:
            # --- NEW: Force HTTP Protocol ---
            # This is the fix for the "405 Method Not Allowed" error. It tells the
            # exporter to use standard HTTP/protobuf instead of gRPC.
            os.environ["OTEL_EXPORTER_OTLP_PROTOCOL"] = "http/protobuf"
            logger.info("Setting OTLP protocol to http/protobuf for broader compatibility.")

            # --- SSL/TLS Configuration for HTTPS Endpoints ---
            custom_cert_file = os.getenv("CUSTOM_SSL_CERT_FILE")
            allow_insecure = os.getenv("ALLOW_INSECURE_CONNECTION", "false").lower() == "true"

            if self.endpoint.startswith("https"):
                if custom_cert_file:
                    if os.path.exists(custom_cert_file):
                        os.environ["OTEL_EXPORTER_OTLP_CERTIFICATE"] = custom_cert_file
                        logger.info(f"Using custom SSL certificate for OTLP: {custom_cert_file}")
                    else:
                        logger.error(f"Custom SSL cert file not found at: {custom_cert_file}. Connection may fail.")
                elif allow_insecure:
                    os.environ["OTEL_EXPORTER_OTLP_INSECURE"] = "true"
                    logger.warning("ALLOW_INSECURE_CONNECTION is true. Skipping SSL certificate validation. FOR DEBUGGING ONLY.")
                else:
                    os.environ["OTEL_EXPORTER_OTLP_CERTIFICATE"] = certifi.where()
                    logger.info("Using default public SSL certificates from certifi.")

            # Set Phoenix-specific environment variables
            os.environ["PHOENIX_PROJECT_NAME"] = self.project_name
            os.environ["PHOENIX_COLLECTOR_ENDPOINT"] = self.endpoint

            if self.use_ax_mode:
                api_key = os.getenv("ARIZE_API_KEY")
                space_key = os.getenv("ARIZE_SPACE_KEY")
                if not api_key or not space_key:
                    raise ValueError("AX Mode requires ARIZE_API_KEY and ARIZE_SPACE_KEY.")
                os.environ["ARIZE_API_KEY"] = api_key
                os.environ["ARIZE_SPACE_KEY"] = space_key
                logger.info("Enterprise AX Mode configured.")

            # The register function will now use the HTTP protocol we set above.
            self.tracer_provider = register(project_name=self.project_name)
            trace.set_tracer_provider(self.tracer_provider)
            
            OpenAIInstrumentor().instrument()
            GenAIObserver._instrumented = True
            logger.info("âœ… Phoenix client configured and OpenAI instrumented successfully.")

        except Exception as e:
            logger.error(f"âŒ Failed to configure Phoenix tracer: {e}")

    def shutdown(self):
        if getattr(self, '_shutdown_called', False):
            return
        self._shutdown_called = True
        try:
            if self.tracer_provider and hasattr(self.tracer_provider, 'shutdown'):
                logger.info("Shutting down OpenTelemetry tracer provider (flushing spans)...")
                self.tracer_provider.shutdown()
                logger.info("âœ… Tracer provider shut down successfully.")
        except Exception as e:
            logger.error(f"âŒ Error during shutdown: {e}")

    # All other methods (decorators, evaluators) remain unchanged.
    def trace_workflow(self, func: Callable) -> Callable:
        @wraps(func)
        def wrapper(*args, **kwargs):
            session_id = str(uuid.uuid4())
            with self.tracer.start_as_current_span(
                func.__name__,
                attributes={
                    "openinference.span.kind": "workflow",
                    "session.id": session_id,
                }
            ) as span:
                logger.info(f"Starting workflow '{func.__name__}' with session_id: {session_id}")
                try:
                    result = func(*args, **kwargs)
                    span.set_status(StatusCode.OK)
                    return result
                except Exception as e:
                    span.set_status(StatusCode.ERROR, description=str(e))
                    span.record_exception(e)
                    raise
        return wrapper

    def _trace_common(self, span_name: str, span_kind: SpanKind, attributes: Dict[str, Any]):
        parent_span = get_current_span()
        session_id = parent_span.attributes.get("session.id") if parent_span.attributes else None
        if session_id:
            attributes["session.id"] = session_id
        return self.tracer.start_as_current_span(span_name, kind=span_kind, attributes=attributes)

    def trace_function(self, func: Callable) -> Callable:
        @wraps(func)
        def wrapper(*args, **kwargs):
            with self._trace_common(func.__name__, SpanKind.INTERNAL, {}) as span:
                try:
                    result = func(*args, **kwargs)
                    span.set_status(StatusCode.OK)
                    return result
                except Exception as e:
                    span.set_status(StatusCode.ERROR, description=str(e))
                    raise
        return wrapper

    def trace_tool_call(self, func: Callable) -> Callable:
        @wraps(func)
        def wrapper(*args, **kwargs):
            attributes = {
                "openinference.span.kind": "tool",
                "tool.name": func.__name__,
            }
            with self._trace_common(f"tool.{func.__name__}", SpanKind.CLIENT, attributes) as span:
                try:
                    result = func(*args, **kwargs)
                    span.set_status(StatusCode.OK)
                    return result
                except Exception as e:
                    span.set_status(StatusCode.ERROR, description=str(e))
                    raise
        return wrapper

class EvaluationManager:
    # This class remains unchanged
    def __init__(self, observer: GenAIObserver):
        self.observer = observer

    def log_evaluations(self, eval_name: str, eval_df: pd.DataFrame):
        try:
            px.Client(endpoint=self.observer.endpoint).log_evaluations(
                SpanEvaluations(eval_name=eval_name, dataframe=eval_df)
            )
            logger.info(f"ðŸ“Š Successfully logged evaluations for '{eval_name}' to Phoenix.")
        except Exception as e:
            logger.error(f"Failed to log evaluations for '{eval_name}' to Phoenix: {e}")

    def create_sample_dataset(self) -> pd.DataFrame:
        data = {
            'input': [ "What is the capital of France?", "Explain machine learning."],
            'reference': ["Paris is the capital of France.", "Machine learning is a subfield of AI where systems learn from data."]
        }
        return pd.DataFrame(data)

    def run_offline_experiment(
        self,
        dataset: pd.DataFrame,
        evaluators: List[Callable],
        eval_model: str,
        eval_name: str = "Offline Experiment",
    ) -> Dict[str, pd.DataFrame]:
        tracer = trace.get_tracer(__name__)
        with tracer.start_as_current_span(f"offline_experiment.{eval_name}") as span:
            span.set_attribute("experiment.name", eval_name)
            
            results = {}
            for evaluator_cls in evaluators:
                evaluator_name = evaluator_cls.__name__
                with tracer.start_as_current_span(f"eval.{evaluator_name}") as eval_span:
                    try:
                        evaluator_instance = evaluator_cls(model=eval_model)
                        eval_df = evaluator_instance.evaluate(dataset)
                        results[evaluator_name] = eval_df
                        self.log_evaluations(f"{eval_name} - {evaluator_name}", eval_df)
                        eval_span.set_status(StatusCode.OK)
                    except Exception as e:
                        eval_span.set_status(StatusCode.ERROR, description=str(e))
                        logger.error(f"Failed to run offline eval {evaluator_name}: {e}")
            return results

