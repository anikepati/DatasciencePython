# apigee_client.py
#
# A reusable Python library for making strongly-typed API calls to OpenAI
# through an Apigee proxy, including automatic token management.

import requests
import os
import time
import threading
from typing import TypedDict, Optional, Dict, Any, List

# --- Type Definitions for Strong Typing ---
# These TypedDicts define the structure of the data, ensuring
# clear, predictable inputs and outputs for developers.

class TokenResponse(TypedDict):
    """Defines the structure of the Apigee access token response."""
    access_token: str
    token_type: str
    expires_in: int  # in seconds

class OpenAIHeaders(TypedDict, total=False):
    """Defines the required headers for the OpenAI API call."""
    Authorization: str
    "Content-Type": str
    "x-api-key": str
    "apigee-custom-header": str  # Example of an additional required header

class Message(TypedDict):
    """Defines the structure of a chat message."""
    role: str
    content: str

class ChatCompletionRequest(TypedDict):
    """Defines the structure of the request payload for OpenAI chat completions."""
    model: str
    messages: List[Message]
    temperature: float
    stream: bool

class ChatCompletionResponse(TypedDict):
    """Defines the structure of the response from OpenAI."""
    id: str
    object: str
    created: int
    model: str
    choices: Any # simplified for brevity

# --- Apigee API Client with Singleton-like Token Management ---

# This variable will store the single instance of our client.
_apigee_client_instance = None
# This lock ensures thread-safe singleton creation.
_singleton_lock = threading.Lock()

class ApigeeOpenAIClient:
    """
    Manages API calls to OpenAI via an Apigee gateway, handling token
    authentication and custom headers.

    This class implements a thread-safe singleton pattern for token management.
    The same token is reused until it expires, preventing redundant calls
    to the Apigee gateway.
    """
    def __init__(self, client_id: str, client_secret: str, apigee_url: str):
        """
        Initializes the client with gateway credentials.

        Args:
            client_id (str): The client ID for the Apigee gateway.
            client_secret (str): The client secret for the Apigee gateway.
            apigee_url (str): The base URL of the Apigee gateway.
        """
        self._client_id = client_id
        self._client_secret = client_secret
        self._apigee_url = apigee_url
        self._access_token: Optional[str] = None
        self._token_expiry_time: Optional[int] = None
        
    @staticmethod
    def get_instance(
        client_id: Optional[str] = None,
        client_secret: Optional[str] = None,
        apigee_url: Optional[str] = None
    ) -> "ApigeeOpenAIClient":
        """
        Returns the singleton instance of the client.
        
        This method ensures that only one instance of the client is created,
        even in a multi-threaded environment.
        
        Args:
            client_id (Optional[str]): The client ID for the Apigee gateway.
                                       Required for the first call if not in env.
            client_secret (Optional[str]): The client secret for the Apigee gateway.
                                           Required for the first call if not in env.
            apigee_url (Optional[str]): The base URL of the Apigee gateway.
                                        Required for the first call if not in env.
        
        Returns:
            ApigeeOpenAIClient: The single client instance.
        """
        global _apigee_client_instance
        # The "check-lock-check" pattern for thread-safe singleton
        if _apigee_client_instance is None:
            with _singleton_lock:
                if _apigee_client_instance is None:
                    # Use provided arguments, falling back to environment variables.
                    _client_id = client_id or os.environ.get("APIGEE_CLIENT_ID")
                    _client_secret = client_secret or os.environ.get("APIGEE_CLIENT_SECRET")
                    _apigee_url = apigee_url or os.environ.get("APIGEE_URL")
        
                    if not _client_id or not _client_secret or not _apigee_url:
                        raise ValueError("Apigee client ID, client secret, and URL must be provided or set in environment variables.")
        
                    _apigee_client_instance = ApigeeOpenAIClient(_client_id, _client_secret, _apigee_url)
        return _apigee_client_instance

    def _get_access_token(self) -> str:
        """
        Retrieves a valid access token from the Apigee gateway.
        This method handles token expiration and renewal.
        
        The Apigee gateway typically issues tokens with a short lifespan (e.g., 3600 seconds, or 60 minutes).
        This logic proactively requests a new token when the current one is within a 5-minute buffer of expiring.
        """
        # Check if the existing token is still valid.
        if self._access_token and (self._token_expiry_time is not None) and (self._token_expiry_time > (time.time() + 300)):
            print("Using cached token...")
            return self._access_token
        
        print("Token is expired or not found. Requesting a new token...")
        
        # In a real-world scenario, this part would be more robust with
        # retries and exponential backoff.
        token_url = f"{self._apigee_url}/oauth/token"
        headers = {'Content-Type': 'application/x-www-form-urlencoded'}
        payload = {
            'grant_type': 'client_credentials',
            'client_id': self._client_id,
            'client_secret': self._client_secret
        }
        
        try:
            response = requests.post(token_url, headers=headers, data=payload)
            response.raise_for_status()  # Raises an HTTPError for bad responses
            token_data: TokenResponse = response.json()
            
            self._access_token = token_data.get("access_token")
            # Calculate the new expiration time
            self._token_expiry_time = time.time() + token_data.get("expires_in", 3600)
            
            return self._access_token
            
        except requests.exceptions.RequestException as e:
            print(f"Error getting access token: {e}")
            raise

    def chat_completion(self, 
                        request_payload: ChatCompletionRequest,
                        custom_headers: Optional[Dict[str, str]] = None
                        ) -> ChatCompletionResponse:
        """
        Sends a chat completion request to the OpenAI endpoint via the Apigee proxy.

        Args:
            request_payload (ChatCompletionRequest): A strongly-typed dictionary
                                                    with the request body.
            custom_headers (Optional[Dict[str, str]]): A dictionary of additional
                                                       headers to include in the request.

        Returns:
            ChatCompletionResponse: The strongly-typed response from OpenAI.
        """
        # Ensure we have a valid token before making the call.
        token = self._get_access_token()
        
        # Define the base headers.
        headers: Dict[str, str] = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json",
        }

        # Merge any user-provided custom headers.
        if custom_headers:
            headers.update(custom_headers)
        
        # The URL for the actual OpenAI API endpoint, accessed through the proxy.
        openai_endpoint = f"{self._apigee_url}/openai/v1/chat/completions"
        
        try:
            response = requests.post(openai_endpoint, headers=headers, json=request_payload)
            response.raise_for_status()
            
            # Use the TypedDict for the return value to ensure consistency.
            return response.json()
            
        except requests.exceptions.RequestException as e:
            print(f"Error during OpenAI chat completion call: {e}")
            raise




# main.py
#
# This file demonstrates how to use the ApigeeOpenAIClient library.

import os
from apigee_client import ApigeeOpenAIClient, ChatCompletionRequest

if __name__ == "__main__":
    # In a real application, these would be loaded from a secure source like
    # environment variables.
    
    # 1. Get the singleton instance of the client by providing credentials.
    # For a production application, you would load these from a secure source.
    client_id = "your_client_id"
    client_secret = "your_client_secret"
    apigee_url = "https://your-apigee-gateway.com/v1"
    
    api_client = ApigeeOpenAIClient.get_instance(
        client_id=client_id,
        client_secret=client_secret,
        apigee_url=apigee_url
    )

    # 2. Define the payload for the OpenAI chat completion call using the TypedDict.
    chat_payload: ChatCompletionRequest = {
        "model": "gpt-3.5-turbo",
        "messages": [
            {"role": "system", "content": "You are a helpful assistant."},
            {"role": "user", "content": "Tell me a joke."},
        ],
        "temperature": 0.7,
        "stream": False,
    }
    
    # 3. Define the custom headers that the developer wants to pass.
    # The library handles the "Authorization" header for you.
    custom_headers = {
        "apigee-custom-header": "my-special-value"
    }

    try:
        # 4. Make the API call, passing the custom headers.
        print("Making the first API call with custom headers...")
        response = api_client.chat_completion(chat_payload, custom_headers)
        print("Response received successfully!")
        print(f"Assistant: {response['choices'][0]['message']['content']}")
        
        # The token is now cached. Subsequent calls will reuse it.
        print("\nMaking a second API call. The token should be reused.")
        response2 = api_client.chat_completion(chat_payload)
        print("Second response received successfully!")
        print(f"Assistant: {response2['choices'][0]['message']['content']}")
        
    except Exception as e:
        print(f"An error occurred: {e}")



requests
typing_extensions
openai
